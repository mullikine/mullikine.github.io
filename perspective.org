* I must get in the habit about blogging about things I read
And just do this non-stop.

* Stop installing everything and simply follow more articles. Only install partially and sometimes
I must merely focus on my own learning
environment.

This is all that really matters.

Actually, I should also just be really casual
with following tutorials as best as I can,
particularly if they are about text and AI.

I need to be able to actually read such
articles.

Being able to read articles about NLP is
important.

* It's important to keep learning emacs and new languages
But I should probably lean more heavily on existing tools.

* I know that if I simply continue to invest in emacs, I can be save for some time

* I do think, actually, that I need to be in a research position

* Start saving for a more powerful computer
Every week put $50 in towards it.

* It's important to focus on mastering emacs -- emacs changes rapidly
I should probably think about upgrading the version.
Also, in order to understand emacs of the future I should be learning advanced emacs lisp syntax.

* Dired is better than ranger for most things because of its integration with emacs

* TODO It's more important to learn emacs plugins and emacs lisp syntax than to create my own plugins

* It's important to continue acquiring emacs skills
If I continue doing this I will actually get all the NLP jobs.
People want to attract PhDs but what they really need are developers who can use apply the research of others.

* How to get an NLP job -- informative
https://blog.ycombinator.com/how-to-get-into-natural-language-processing/

* TODO I should just do more NLP research. I think I probably need to get back into university in order to do that, but it's bullshit. How do I get work in this area?
I should aim to do this. But perhaps not at Otago.

https://nlppeople.com/job/artificial-intelligence-natural-language-processing-software-engineer/

Look abroad. It's the only way.

* I should be applying for research jobs at universities
I need to try to get into Natural Language Processing.

I don't really want to learn all the terms
surrounding k8s, for example.

This is definitely not what I want.

I want to be learning algorithms.

* I have to abstract my evironment away. Files are a useful concept, but only if I build upon technologies such as filesystems. I have to abstract away
Use files only as temporary storage.

* Nellie is kinda ignoring me but that might just be because people these days are very busy and we have to try very hard

* I have to organise my blog so that people can see the types of things I'm reading about
For example, scalability.

Therefore I need to talk about things like software design principles.

* Maybe I actually should get into =.NET=
Because having emacs skills would come in real handy as few =.NET= developers would have such skills.

* Focus more on learning about the languages I use

* Lean more heavily on magit and other version control tools in emacs
They are seriously powerful and will be important in the future.

Get to know emacs more intimately. Definitely worth it.

* I must start learning without needing to understand the axioms
To be able to learn latent spaces is important.

* My glossary system might not be the actual best way to learn
https://senrigan.io/blog/chasing-10x-leveraging-a-poor-memory-in-software-engineering/

* Everything I do from now on must be purposeful

* I must approach my learning with the perspective that I'm simply aiming to use all of these tools and to be good with computers
Expert level python is unnecessary.
The ability to swim is the most important thing.

* I should have more confidence, though it's basically too late now
I was right, by the way.

* Focus on emacs. This require discipline. It's all that's required
Keep integrating and understanding the functions which are used to build all this amazing emacs software.

* It's important to learn haskell theory - Spend all day on that today
Computer Files Are Going Extinct

* I need a really good memory to get good at haskell
I have to memorise the syntax and language extensions.

* If I want, I can get as good at a particular technology as Andrew Paxie is
That would probably just be python -- but extreme understanding of python.

Is that what I want though? Well, it would mean I would most likely have some work.

But it's probably not what I would want. I would want to master haskell, actually.

Haskell seems more future proof.

* TODO It would be ultra nice to have a seek interface to emacs

* I actually should have a job right now -- It's important to get anything I can
I need to be building my life. Fuck. It's just not fair.

Get anything I can.

* Keep integrating useful tools into emacs -- this is the way to get truly better at what I do
Keep integrating useful tools, which solve new classes of problems. It's important to do so.

* Lisp is actually really great for hacking on things -- haskell will be great for hacking on things one day
But right now lisp is better for hacking on things.
Focus on mastering emacs.

* It's very important to be programming in haskell
I'm not doing it. As I wait the world will become increasingly more confusing.

* I have to be writing code from within emacs without inhibition -- this is the only way to get good
Any steps I make in this mode of operation will help me.

* I have to continue integrating -- this is important

* Things feel bad -- Reality is kicking in. It feels like I am boring. I need work so I be more of myself

* I should be designing software that will be utterly magical in the future
Therefore, I need to know haskell well.

But not just haskell.

Yes, haskell, but it's not expressive enough for everything that I need.

It's possible that haskell will evolve, though.

* I have to start doing and learning some serious haskell
Yes it's hard but it will be amazing one day.

But how hard will I have to go on it?

I will have to put much of my energy into it.

* How to even approach making a modern game? It must start with a game engine

* One thing I know the future will be like -- is that we will thrive in a world where do not understand much about what is going on at all
This is because devices can understand for us.

* Maybe I should actually be trying to understand how things like the transformer actually work

* I think it's probably impossible to keep my cool
My energy needs to go somewhere.

I should direct it into something beautiful
rather than into the ground.

That requires bravery and conscientiousness.

* Do not acquire skills which I will not need in the future
Do I need unity skills? No. Focus on language processing.

* Everything in emacs I go to often should have a key chord associated with getting there
Even something like customize variable? What was the name of that variable? I need a function for finding that name.

* If I am to be truly good at Rust then I need to be able to work on a project
I should aim to give myself the skills I need to be able to focus on a project to completion.

* I need any kind of developer jobs

* If a person wants to build anything, it requires work
No matter how much you automate, it will always require about the same amount of work to create something new.

Therefore, search is more important. A relaxed attitude to learning is important. Save my energy.

* It's important to make bindings for conceptual things

* Just make lots of search tools. This is seriously how I should learn
** DONE Make bindings for this
#+BEGIN_SRC sh :async :results verbatim drawer
  j hyperpolyglot
#+END_SRC

https://rosettacode.org

* In order to become good at python with emacs I must use emacs a lot

* I need to get a job
It's ridiculous not having a job. Seriously.

Almost any job will do.

Do my job well.

* I should anchor all my snippets to a language
Use the names of that language's functions as names of the snippets.

* I should try to focus a little bit more, say on haskell exclusively

* Stop working on things that are not futuristic. That is a huge waste of time
Learn more haskell.

* I should continue to build NLP tools for emacs
Actually, I need to abstract away all the algorithms.

* I should try to get better at using the more basic, statistical algorithms before advancing onto the more powerful ones
This way, I can find more jobs.

** It might be important to do some statistics
I don't want to do it at uni, but I must blog about it.

* It's possible that web scraping libraries would provide an easier experience for extracting the actual article from a page
It would be better to apply deep learning models to perform functions that would be difficult for a human.

* Keep applying for data engineer jobs
This is what I am.

* Consider using jtc instead of jq
$MYGIT/ldn-softdev/jtc

* Read and review more focusedly

* I must disable most modes for term-mode. Use manage-minor mode for this
I need to have a binding which gets the map for a binding, so I know which minor mode to disable to remove a binding.

* I need to become better at parsing emacs buffers

* Be more flexible, but stay within the terminal. Rely on search to find tools. I must always be able to integrate
Keep doing this. It will all work out in the end.

* It's more important to float on top of technologies then get ultra deep into any of them
This is because they are designed to abstract their own interfaces.

* improving at programming
** I must become much stronger at writing
- wordnut

** I must become much stronger at haskell

** improve
*** python
*** golang

** I must become much stronger at emacs
- create plugins like wordnut

I have to float on top rather than sink deeply into plugins.

* I want to be able to search the #emacs IRC conversations with regex
Either run irssi inside emacs or use erc.

* Getting better at emacs might be the way to getting better at everything -- seriously
Everything must happen inside emacs.

This is very important.

* For my blog
List synonyms for two words
Find two matching words with the same first letter.

** I need the API for =thesaurus.com=

** [#A] I could extend =wordnut= for emacs to do this
This is the best way to do this.

I should be getting better at extending emacs.

* I need to be doing game reviews too -- just of text-based games

* Just keep doing what I do best. Emacs is going to lead me on a wonderful journey
Keep hitting emacs as hard as I can.

* When I review papers I should review them to learn
It has to be very easy to review.

Therefore, make it so I can easily do things
like 'rate' sentences according to importance.

** Make scripts to minimise natural language. Use acronyms for everything

* I have to act true to my feelings more often
This is going to happen!

* Chen
You have 3D voxel embeddings for spatial image segmentation.
But what about learning the bounding boxes of causality.

* Is it possible that I need to become less detached?
Attachment is not sustainable. Attachment means expending more energy on meaningless things.

* Rather than focusing on getting job titles, I could review books -- and work towards writing a book, perhaps

* Get better at solving bigger problems -- and integrating

* XMPP is actually futuristic
https://www.briskbraintech.com/xmpp-a-communication-protocol-for-the-internet-of-things/

* It's important to get good at creating emacs modes and plugins
This way I can easily integrate things into my unchanging emacs environment.

* Every time I want to write some code which I will use at a later stage I should make a yasnippet

* It's important to continue trying to get better and better at emacs
This should be my main focus.

* It would be embarrassing for emacs to not work with certain languages
Emacs must work. Take a b-line towards it working for everything.

* I must keep trying as hard as possible to get out of the metaphorical box
The thing is, when people get to know me they will see and they will want to help me.

* I do not want my programming experience to be interrupted as I am using TabNine
Therefore, when I press space, it should not finish the completion.

* I can ask anyone out that I want. I should be efficient about this
There is actually probably a decent chance I will get the person I ask out.

I'm a very worthy candidate.

** I am simply taking my time because I need to secure my career
It's almost a prerequisite to marrying someone.

** I have to break down all those anxiety barriers and become a socialite
Then the girl will appear very quickly.

* I need to upgrade my environment with some NLP editors tools
What I really need is a language for NLP.
For describing automated parsing and filtering.
I need to be able to construct editors for doing useful things.
I think it's important to learn some more haskell.

* When I leave Dunedin, basically everything is going to blow my mind (because of technological progress)
https://www.facebook.com/pages/Artvo-Robina/2371065509816449

* Org mode isn't exactly getting more complicatd / expressive on me
I need to move to more expressive languages.

* It might be important to have some practice at programming in Go

* What I really want is a programming environment which writes code for you
For eaxmple. You write what you want to happen declaratively and the code remains =up-to-date=.
One day in the future you look at what code is being run under the hood and it looks completely different.

Perhaps that is what emacs is, in a way.

* It's important to be using haskell because I only want to learn one function name for each task and only one way of using it
For example, a caching function / monad.

* I must get to the stage [with all major programming languages that I use] where I don't care about forgetting about scripts I made
I must have developed great search functions and organisation where things just take care of themselves.

* It's more important to be able to scrape the web and create parsers that do such things rather than use someone else's API for this
Being able to scrape arbitrary things is important.

It's not able the results its about the method.

The method is more important because it's reusable a marketable skill.

* I need to be aiming for GPT-2 search for everything

* Just keep breaking down the barriers to coding for a specific purpose (such as using 'The Transformer' in python)

* It's important to push as hard as I can on using NLP because the world will start changing very rapidly

* I should be making lots of predicate functions / shell scripts
Ideally, I should be writing in a scripting language with decent documentation.

But I need to *harness* shell scripts to do my
biding.

I can use them by calling them from a superior language.

What is the language I want to be learning? Rust perhaps?

I should learn something which is a bit more powerful than what I'm currently doing.

Perhaps I should use racket.

I would like to be using haskell but it seems a bit too difficult to hack scripts together.

That being said, I would learn a lot.

But only if I would actually be learning a
lot.

I will be able to accomplish more things.

Name them appropriately.

- port-open-p

* I need to be generating and remembering all code i write instead of making these black-box shell scripts

* Simply use emacs modes. Over time I will get good at them
Focus on improving search and learning tools and bindings only.

* Work towards a very strong emacs editing environment. I'll need it
Keep making my emacs environment better.

I have to make it a heck of a lot better in order to dominate in the workforce.

* I should try to get much better at functional programming with emacs lisp

* [#A] One reason why lambdas are so useful is that I don't need to slugify parameters to come up with a function name

* Learn haskell for the expressiveness

* Learn Go for jobs

* I must take further control of programming
Remember to switch to haskell, though.

Remember to switch to haskell

* Consider just being more of myself. What does that even mean? Do I go back to my mullet? No.
Find the same confidence I used to have somehow.

Remember my past. It will help me to find perspective in the future.

* It's expected, given the help available on the internet, that people should know how to take care of themselves
+ Or at least either:
  - have basic needs sorted (keep it to yourself)
  - have chosen this

* [#A] I have to use my emacs knowledge/strength to learn another language. I then use that language to relearn emacs at a later stage
This is a cleaner way to do things than to try to upkeep emacs forever.

Plan to relearn emacs in the future but with the assistance
of amazing search tools that do not exist yet and 
are based on the most expressive language I know of, haskell.

Basically, use emacs to learn haskell to
mastery and then use haskell in the future to
learn a new editor (perhaps an evolved emacs)
to mastery.

* The future of IRC or instant messaging in general is one where many users share the same chatroom. All voices are superimposed on eachother
Multiple voices turn into a single or fewer voices.

* I need to be very bold when asking anybody out. The fact is that I'm basically a genius and will have AI superpowers in the future

* It's possible that all known brain diseases will be solved in my lifetime. But at that stage there will be new problems

* My friends list should consist primarily of new people
Get in the habit of making new friends.

This will be very important.

In the future it's important that I do not
have any anxiety at all which I cannot
overcome.

* I need new friends and higher quality ones
I should consider talking to more very
intelligent people who are a bit older than
me.

I will definitely feel the need for guidance
in the future.

That being said, if I develop a habit of
solving my own problems then I will not feel
the need to ask others for advice.

I prefer that approach.

The day I need to start asking for serious
advice I should be asking from an AI which is
able to think a lot better than any human.

* As my anxiety disappears I can feel myself becoming more relaxed and being able to talk to more people
Keep a realistic perspective, remain healthy
in my mind and I will not have any anxiety
about talking to people.

* The world is going to start changing very rapidly due to AI
It's going to be a rollercoaster.

I need to be able to take care of people.

Work on myself.

* Allow myself to grow up

* Take a little bit more of a cynical perspective towards friends, but interact in a meaningful way
What I mean is, most people are transient.

See it for what it is.

But then see that they are also here at this
moment, which makes the moment more important.

* Being a Christian is about more than just being happy

* Rosetta code is great but I need to improve it

* I have to be able to do recursion in any language -- this is important to drill into my mind
Start with emacs lisp

$MYGIT/acmeism/RosettaCodeData/Task/Find-limit-of-recursion

* I have to consider that the world has actually changed quite a lot since I was 20

* Think of everyone on facebook as if they do not yet have anyone talking to them
While I am not talking, they are not activated.

* It's very important to continually learn and improve my emacs environment in a sustainable way

* I'm a little socially bankrupt at the moment
Therefore, my perspective on what are healthy
relationships is a little warped.

I have to try a little bit harder to be a
peaceful person.

But I'm able to be social.

I just have to exercise my socialness.

* Think about how much better my life would be going if I had invested in bitcoin early
Everything would be easier.

Well not everything.

Money can't buy you everything.

It certainly helps though.

* It's actually really important to invest in bitcoin
It's going up and never coming down.

* So many people got degrees. What is the point of learning? If a person starts learning and never stops they are bound to use their degree to the fullest potential
And when they do it will be amazing.

* This is true but I can't say it
I'm going to tell you something true.

You are beautiful inside and out.

I may be a bad person for liking you the most
but it's true.

** Truthfully, it's not possible to tell the truth anymore
The truth is, a person's personal truth is
valid only in the moment and to that person.

Even still, personal truth is composed of
multiple truths fighting for supremacy.

It's more like a complex waveform

* Nellie was amazing but I am the most amazing person ever -- believe that and good things will come to me

I need someone who will take care of me.

I need someone who can fill the emotional
needs I have.

* I need to become part of the =FSF=
Become part of the free software foundation.

Make some plugins for emacs.

Put them on melpa.

Then I'l be part of a powerful club.

* I need to break out of my shell -- which I am doing
Be more confident and talk to far more people
than I currently do.

It's super easy.

But I have to realise that it takes skill to
talk to people of different ages and
backgrounds.

** I should simply talk to people who I haven't talked to in a while
And not have deep conversations.

* If a person knows how to work with an amazingly expressive language, it's probable that *cheap* services will exist to allow me to run code
Therefore, the only thing I need is to be able to do something.

I only need to learn what I need to learn and someone will give me the wheel.

Become a great driver and someone gives you the wheel of their car.

Become a great programmer and someone gives you control of their software system.

* One day, editors that are very powerful like emacs will exist but for more interesting languages
Therefore, I should be trying hard to learn the most expressive languages.

* Nellie is still the best so far, personality-wise
That being said, she's still someone who may undermine me and may not have my back.

* I should be learning more tools for Natural Language manipulation
This is important.

I should also be learning about category theory and really solidifying how Haskell works.

Continue to learn Haskell.

Move towards NixOS.

* Perspective
It's possible that modern human kind has
evolved from many vastly different humanoids.

http://www.digitaljournal.com/science/40-000-year-old-bracelet-from-extinct-human-species-discovered/article/432798

This means that the future of Earth could, of
course, by the diversification of the human
race again through genetic manipulation.

** I do not believe that science precludes Christiantity

* My mind has to sit inside something. It has to be a cog inside something in order for me to be most effective
Can emacs provide that kind of holistic satisfaction? Not currently. It's not powerful enough.
What could be?
I do need to put myself inside something.
emacs is, however, the type of thing I need, albeit an early version of it.

* Don't move to =NixOS= until someone else is writing those =.nix= files because I'm not going to
i.e. don't move to =NixOS= until an opinionated distribution in the likeness of =spacemacs= exists.

* It's important to switch immediately to NixOS
** Otherwise I am going to miss out on so much in the coming years
I have made it to the top of emacs, kinda.

I need to do the same now with NixOS.

Ideally there will be a starter kit.

#+BEGIN_SRC text :async :results verbatim drawer
  15:32 < ivan> libertyprime: you don't really need a distribution, you can take anyone's configuration from github :-)
  15:32 < libertyprime> ivan: cool sounds great :)
  15:34 < ivan> libertyprime: "turn on plasma5 and add whatever you need to systemPackages" opinionated setup right there
  15:34 < libertyprime> is there a particular config you would recommend? https://github.com/bjornfor/nixos-config looks popular
  15:34 < ivan> I guess I don't really recommend copying someone's configuration until you have a need for something to be different
#+END_SRC

https://github.com/bjornfor/nixos-config

* I need to get to the stage with python (and any other language I want to be good at) where I can copy modules/plugins and use them as templates
$EMACSD/packages26/gist-20171128.406/gist.el

#+BEGIN_SRC sh :async :results verbatim drawer
  j gist-list
#+END_SRC

* If no girlfriend of mine wants to learn emacs or even try to counter AI then fuck them. I basically deserve anybody I want
Because I will take care of them.

* Keep up my =emacs= skills at all costs

* The ability to continue learning is extremely important
There is a resource that a lot of people are
using up -- their ability to continue
learning.

I, however, am able to continue learning
indefinitely because I am building on a system
which I designed myself.s

* Simply continue getting better at emacs
I am learning so much.

This is why it's so amazing.

* TODO It's actually seriously important to start making huge progress with a mainstream programming language

* Before getting good at haskell I need to use =handle.el= to streamline all my common bindings

* Being able to read is a very important skill
The ability to learn new words is extremely important.

One day all the work I do into learning haskell will come into play to allow me to continually learn.

* I should be making new friend all the time
I need friends that I can lean on for assistance.

* I should upgrade to =erc= for emacs so I get the benefits in the future
Do this later on a different machine.

I should never upgrade my operating systems, only spread to 

* It's important to understand the things which will last
Haskell is probably quite important.

* I should learn tools and libraries which help me to make sense of the world
I need to learn languages (all types) which are able to describe the world around me.

* I am actually good at emacs now
And reasonably good at python.

I should try to get better at other languages too.

** [#A] Stick to learning languages which have a future
Whether a DSL has a future is hard to say.

The reality is that most do not.

* I have to be working towards the mastery of all the languages that I am using
Ideally, I should be working towards the mastery of only the most abstract and expressive one.

* This is how I should work
https://workplace.stackexchange.com/questions/145709/how-to-discipline-overeager-engineer

* I have to get deep into internet jobs
https://stackoverflow.com/jobs/directory/developer-jobs

I have to kickstart my internet job life as I also need to kickstart my dating life.

* tmux inside emacs
** As it turns out, tmux looks OK in emacs. It colors everything as it goes from 256colors to 16 colors
** I need to find a way of sending function keys to tmux from emacs
=ansi-term= needs to pass these bindings through.

* I must simply be my happy self
This is important.

I want to get into a relationship where I can share things that make me happy and feel comfortable.

* AGI
https://openreview.net/forum?id=SyxQ_TEFwS

* I need to be learning file formats like =org-mode= but which are designed to be infinite streams, distributed and scalable
Similarly pure to regex.

* I have to master emacs as soon as I can -- this is important
That means getting to know it intimately.

=emacs= is going to be the source of my power.

* I have to be making search tools inside of emacs

* Imagine a situation when you need to remember things, such as an emacs command
Or a haskell function.

Now imagine that you have to recall it or you die.

This is how important such things will be in the future.

Therefore, I need to do my best at learning properly.

* TODO [#A] Every day I should write notes and blog about a website or youtube video
Creating structures will enable me to actually get through more material.

Just as =org-mode= enables me to manage more things.

This is very important.

I need to be learning something abstract and valuable every day.

* The more abstract code I am writing the slower I will have to relearn

* I must be learning much faster than I currently am
I'm not learning fast enough.

Therefore I must learn =todo-mode= and other things.

* traction
** The more traction I get with emacs the better. Make sure to be covering my own ass as well

** I have to gain traction with haskell and other languages
Traction is everything.
If I get more traction with emacs then that's amazing.
I must actually know the emacs lisp language very well.

* dating
** I have broken up. Therefore I need to find another girl. Just because I have experienced a breakup doesn't mean that I am weird

** I should be asking someone out who I see a future with, not just someone who I think is hot
Therefore I should ask Amy about who she is, to find out, before I ask her out.

I should be asking out the person who needs me.

** If I can choose to risk it with a prettier girl after an equally young one breaks up with me then I deserve to have the chance

** In order to actually get a girl such as Amy I have to become less weird around people like her
That would be almost impossible unless I can gain acceptance from her friends.

Maybe I should try anyway.

It's possible I have simply had really bad experiences and the problems are all in my mind.

They are. The number one rule is that I must expect nothing and simply see later if it develops into anything.

One thing for sure is that most of the problem with askign Amy out is simply my own anxieties.

Yes, there may be other problems but it's mainly me.

Overcoming that problem, for instance, would open up other doors.

** If a girl is 20 then she can marry whoever she wants -- seriously
Therefore, I need to be bold about this.

Break people's illusions about everything when I ask her out.

* I should get to know some of the most useful python libraries
http://greenteapress.com/thinkpython/html/index.html

* I should be writing programs that utilise GPT-2 right now
Also, I need to be shedding weight and simply understanding what is going on.

* Continue to integrate emacs modes for a while until I can really build a truly epic environment for python

* When I make glossaries, I should write them like this
#+BEGIN_SRC text :async :results verbatim drawer
  resigning
      Perspectives:
          An act of attrition against your team.
#+END_SRC

* I must actually go hard on talking about NLP stuff on my blog, building up glossaries and referring to them
I really just need a great notetaking environment.

* Keep trying to learn probability and machine learning concepts -- it's important to understand them

* When I am blogging, I should be setting up environments and proving that they are running

* Keep working on emacs
It's definitely worth doing.

* Start dedicating time to watch youtube videos
Watch from StrangeLoop, because they are quality videos.

* In order to ask out Amy I must first try to have a conversation with her
What will I talk to her about?

* I'm only good looking at this point in my life. It may not be the case always
Therefore I must get girl now lol.

* I really need to blur the lines between emacs and the terminal

* It's true that you need to be prepared before you date someone
Preparation means satisfying the expectations the other person has as best as you can.

For example, it may mean having a job.

* being depressed is extremely risky 
It's dangerous.

* I have to be more of myself
If I don't watch what's happening to me I will find that I am becoming
more like someone I am not.

Imagine what I am when I am happy. If I am my perfect self then this
will most likely make other people awkward, because awesomeness is
indimidating.

Therefore, I should really think about the kind of person I want to be
and try to be more and more like that every day.

* Saying happy birthdays to someone on a facebook wall is kinda reserved for their current friend group
So they can feel special when they see they are one of a small group who said Happy Birthday.

Kinda like being at a birthday party. It should be fairly exclusive.

That being said, facebook is not like the real world. It's not normative, but is empirical.

* I need to aim to become a master of the English language
I should do this via my terminal.

This is actually very important.

* Be confident about myself and tell Fiona the truth -- all of it

* Tomorrow tell Fiona lots of nice things about herself

* When I play C&C I have an epiphany. My life is so much more important than wasting it dating girls, etc. Ask them out. Marry them almost immediately after. Definitely
I should actually think about marrying one of them.
Fiona is really cute. I like Fiona.
Amy is really hot. I like Amy too.
I would definitely consider asking Amy out.

* The future of coding with my fingers is mapping concepts to emacs chords/gestures
It must always feel intuitive.
Similar chords should be very similar.

* I actually do need to be continually learning
Stop wasting time on my computer and do more actual .

* Scalability should be the first and most important part of the languages/environments I learn
I'm not talking about the libraries. I'm
talking about coding on pure dependency.

Instead of building towers, design
spacestations that float between hypothetical
towers. One day the towers will climb so high
that there will be new paradigms. These are
the paradigms I must design for.

* Spend as much time as possible creating snippets

* Editors in the future
- all bindings will be learned
- Emacs will be dead one day or greatly changed
- text terminals will still exist but it will require lots of consolidation of information to generate code which I then edit
- projects will be generated fresh at the point at which you need to edit them
- how long it takes to make your edit will be important
- Languages want to be maleable and therefore:
  - declarative
  - expressive
  - multi-dimensional

** Keep in mind that creating an environment such as mine gives me the edge
It's like a skeleton for a body. BUT ONLY IF it is written in a scalable and maleable language.

* I need to be a lot more active, mentally

* I need programming software which really lifts me up
This means the foundations mus tbe built on AI funcitons and APIs.

Functional programming is extremely important, at least the core theory of it.

The functions themselves are not so important.

* I am a child of God. My sinful desires will be passed away from me

* Just be my best self. Not even nervous

* I should be learning my way around things such as this
** Generate combinations/enumerations using problog
$MYGIT/mullikine/problog-examples/rolling-dice.problog

* [#A] People think being unconscientious is a bad thing. But what if it means being able to love someone who is a mess?
The it's a good thing to look past that person's faults.

I should not perceive that being able to live amongst mess is
necessarily a fault of my own.

It is not a bad thing but is actually a selfless quality. At cost to
your own image of being a mess lover you become able to sympathise with
others.

#+BEGIN_SRC text :async :results verbatim drawer
  conscientiousness
      The quality of wishing to do one's work or
      duty well and thoroughly.

      Not walking past a mess. Upon seeing the mess, wanting to clean it up before continuing on.
#+END_SRC

* I should be very focused with the things I blog about
What I'm learning must build up and compose.

* I should become as good as I possibly can at emacs
This means parsing emacs lisp.
Remaining a master of emacs will make me part of a special club with hacking superpowers.

* What people tell you doesn't matter. It's ok to date people at different stages because the world is changing
Don't get so comfortable with your own mental superiority due to age when AI exists.

* Many geniuses exist. But no opportunity prevents them from reaching potential
https://ourworldindata.org/talent-is-everywhere-opportunity-is-not#lost-curies-and-einsteins-in-history

* I must focus as much as I can on the abstract things which will come to fruition in the future

* It's fine to put code in my glossaries
#+BEGIN_SRC sh :async :results verbatim drawer
  vim +/"^Transport Security Layer" "$NOTES/glossary.txt"
#+END_SRC

* emacs is comfortable enough now
I need to start using it for more things.

* Stop spending so much time polishing my emacs
Learn =parsec.el= for starters.

* I probably want to use parsec to construct parsers

* I must keep going with haskell -- it's important to get good at it
The environments are getting better and better with emacs.

I would have to go hard on it for a while to get to a level I am happy with.

* I don't want code rot to destroy what I have worked for in my terminal environment
- Start using emacs' straight.el
- Start using nixos

I need to be using the best package
management, even if I'm not using it
exclusively.

Package management is important.

https://github.com/magnars/dash.el/pull/277#issuecomment-482494706

* Stop trying to shoehorn *everything* into emacs
I need to spend most of my time learning the languages themselves.

I will need to use GUI programs such as google chrome for a long time to come.

* Don't bury my head in the ground with racket. I must do what is easy
I can learn racket but I have to do it by mastering emacs first.

* I must be seeking to understand emacs intimately as I master the editor
It's far more than just an editor.

* parsec.el is definitely worth learning
It's so easy to learn and will help me learn the real parsec.

* My emacs should have 0 lag
Lag is very bad in emacs world.

It's like stopping a bullet train every time there is lag.

* I have to get better at using real languages and reinventing the wheel less
Therefore, I should dedicate much more time to simply reading documentation, or doing tutorials ideally.

* Keep getting better at emacs -- it's so worth it!
But this means that I need to get into parsing emacs lisp.

* I have to be studying python like I'm studying something that will be extinct one day and I need to know what it will evolve into

* Do not ever think that my environment is good. The only way it's ever going to be good enough is if it is magical

* The more work I do on my blog and as far as NLP goes the more chance at getting a job I will have

* The onus is never on the user to self-manage
I should rely on other people becoming so
incompetent that they need the corporations
who's software they are using to take the
flack for things such as copyright
infringement.

Because it's a necessity.

* Write blog posts which contain mainly links to cool things
$MYGIT/dylanaraps/pure-bash-bible/test.sh

This is still using abstraction rather than
creating abstraction.

I need to be creating abstraction.

* If I can develop the ability to focus intensely on functional programming and learn efficiently then this will save me time sitting on my bum

* I think I am going for a job where I need to have built my own successful open-source software (such as an NLP library)
I would need to be a data scientist specialising in NLP, rather than an NLP developer with knowledge of data science.

Therefore, I should seriously go over the data science videos from here:

https://www.youtube.com/user/Math4IQB/videos

Turn them into blog articles.

Digest the youtube videos.

Rewrite them.

* I should be using emacs and other languages to ingest information from the internet
The wrong attitude is to build outwards when I need to be pulling inwards.

All the plugins I use should be put to use. I need to be combining information.

* Make more commands this way (where the arguments are part of the command)
For autocompletion purposes.

#+BEGIN_SRC sh :async :results verbatim drawer
  pstree-alAsp 11844
#+END_SRC

* This youtube channel here is a huge accomplishment by this person
https://www.youtube.com/user/Math4IQB/videos

If I wish to get a job in this area I will
need to build something like this.

I can do it too, but I must achieve it through
NLP and automation.

AI generation (but could be through the use of APIs).

* If I simply keep improving my vim and emacs while doing NLP tutorials then I'll get very strong at python

* The way to become a 10x developer is by integrating and abstracting

* [#A] Abstracting is better than integrating
Abstracting is like integrating but allows me
to speculate about the set of things which are
abstracted instead of actually requiring
myself to obtain said things to integrate
them.

* It's much more efficient to simply go over articles every day rather than try to come up with new material all the time

* Need to be programming in a holistic way -- it's important to get this right as early on as possible

* I should be doing lots of spacy. Maybe I'd just be doing tutorials. That's enough for the moment.
Seeking to understand.

* I should simply start copying blogs and applying spacy to them

* At Church I should try to get to know some more girls
Dress more nicely.

* I have to understand all the fp concepts so I can make sense of hardcore NLP concepts

* Clown to redundancy meeting
https://www.bbc.com/news/world-asia-49708570

* Need to be working on some ultra specialised but relevent stuff
I should seek these things.

* Damn it I should've been in the right state of mind to talk to Megan while I had the chance. Now I am not

* blog
** My blog should be my cv
I should create tables with links and things to projects I have done.

** Do not go hard on my blog until I have fully automated everything and built up a really decent blogging environment

* Don't learn stuff which I can't build on
A lot of the AI stuff I am tempted to get into, I shouldn't because I can't build on it.
Learn about this stuff but don't actually get dirty with the code unless I can build with it.

* I should definitely put myself in the correct perspective -- keep doing that

* Need more powerful computer so I can use things such as this
https://github.com/NVIDIA/NeMo

* One day it doesn't matter what the format of the file is, it will be easy to parse
$MYGIT/lunaroyster/LaTeX-search/src/Commands.js

* As it so happens, the more fundamental way to call a process is with a list of arguments rather than a single string containing all arguments
#+BEGIN_SRC python :async :results verbatim drawer
  subprocess.call(["cmd", "hi", "hi yo", "hi\""])
#+END_SRC

#+BEGIN_SRC sh :async :results verbatim drawer
  vim +/"def joinargs(args):" "$MYGIT/mullikine/shanepy/shanepy.py"
#+END_SRC

* I must continue doing what I am doing
Keep going with emacs.

* python
This is the perfect playground.

#+BEGIN_SRC sh :async :results verbatim drawer
  py-interact hi yo yo
#+END_SRC

* Take python much more seriously
I really hate python though.

I really do.

I don't want to have to manually import all
this stuff (for example, regex) every time I
want to use it.

** Don't kid yourself. I am not that great at python. But I must become a lot better. Become much better at python
In fact, I must master python.

* Me
** Favorite shape: torus
The torus has an Euler Characteristic of 0.

https://youtu.be/z-GlM7eTFq8?t=189

* My blog will be great if I am constantly blogging

* It's a global market so I should do something very specialised in order to get scouted
Simon Guest's advice.

* I should be using embedded lisps to help generate code but in general I should keep my snippets in the target language

* I must keep making python snippets
Snippets is basically code-gen.

* Keep automating things
Retroactively use search, parsing and filtering to populate lists of things I have read / touched / worked on.

** For example, search for google colaboratory projects from my clipboard or eww history

* Use more colaboratory
https://research.google.com/colaboratory/faq.html#gpu-availability
Learn to use - it's free.

* I really need to be learning a parser ecosystem

* Stick to programming languages I am actually good at -- learn them really well
What works with emacs / the way I work? -- Use that.
Get good at things which are easy to get good at.

* I should be building things into emacs which will be useful in the future

* I should simply try to get really good at parsers from a certain language -- I probably should keep learning haskell

* It's important to keep getting better at programming
It's important to keep getting better at programming

* Emacs needs to have examples of how code has been written in the past
- as I am typing
- based on code from repos I specify

This would be extremely powerful and useful.

* I must stick closely to the python ecosystem
Become glued to it.

* It's more important to improve my ~computational linguistics~ skills than it is to learn functional programming with haskell
This is because computational linguistics will
help me with many more passive things such as
search, negotiation and communication.

* languages for editing is the future of editing. the vim language is a basic example

* Typing is not the bottleneck. THINKING is the bottleneck

* I must embrace working towards proficiency in all programming and natural languages if I am to become good at a single one of them

* Consider simply getting much better at python...

* Keep going with my emacs -- it'll be worth it

* I am pragmatic but not pedantic
Dealing with things sensibly and realistically
in a way that is based on practical rather
than theoretical considerations.

* Get better at understanding word/document embeddings

* I must get better at the languages I intend to use -- this is important
Getting better means acquiring more passive tooling.

* It's important to give Nellie the feeling that I am always there for her to talk
Always respond to her messages.

* Keep going to the marsh to do more programming -- this is quite important as I get so much done here

* It's important to stop programming in lots of different languages and start building something in a single monolithic language
** TODO [#A] Or to simply be building code-agnostic parsers.

* [#A] Realistic view to present in job interview
I want to become good at building programming languages.

* [#A] I must get productive with the languages I am learning

* [#A] I must build some interesting things with BERT
- something in transfer learning

Fuck distractions such as microservices.

Get good at something that I love and that I
think has a future.

* Simplify my CV

* Get better at emacs

* Learn more words
They make me sound smart when I use them.

I have to commit them to memory by writing
down usages of them, or reading usages.

This is fairly important.

* Use google to learn to pronounce words
** imbecile
im· buh· seel

* Learn to read haskell -- writing isnt as important right now
I want a lisp version of haskell.

* One day (soon maybe) we will have neural versions of programs such as vim
We already have hallucinated mario games.

Why not do it with vim?

* I must continually learn tougher and tougher languages

* This makes me a better c++ developer
The fact that all the compile commands are recorded and I can see them.

#+BEGIN_SRC sh :async :results verbatim drawer
  cd "$MYGIT/Swordfish90/cool-retro-term"; qmake && make
  vim +/"\/usr\/bin\/g++" "$HOME/scripts/g++"
  hsqc g++
#+END_SRC

* Set up haskell -- learn it properly

* Need to learn how to use particular machine learning libraries

* I bet it would be amazing to be programming in common lisp
Do I really want to learn it though?

Concentrate on upskilling by focusing on USING language models, not training them.

* Consider simply learning common lisp and then using something like py4cl

* The reason that the keyboard is a great way to interface with a computer and perhasp the best way to do prorgamming
Is because humans have an ideas max bitrate.

* Learn haskell so I can be learning that language which may be used in the future for working with language models using category theory

* My next project should be setting up an english language editing environment within my terminal
I need everything.

** dictionary
I should be constructing my own dictionary.

*** need equivalents
Git pull for pulling new words learned from the outside world.
Git merge for merging language models.

** surface realisation
** syntactic aggregation
** de-ambiguator

* I should be trying to get better at rewriting my own english text using NLU and NLG tools
Meanwhile improving my general programing skills.

* Get better at
** [#A] querying language models
** [#B] creating language models from data

* I do actually have to be reading from google chrome and not just through my terminal
It's easier to learn some concepts when you're presented with an image.

* TODO [#A] Document the various abilities provided by NLP, NLG and NLU libraries
This will give me a better understanding of what is out there.

I need to be integrating them into my own environment.

https://medium.com/sciforce/a-comprehensive-guide-to-natural-language-generation-dd63a4b6e548

* TODO Start searching specifically for NLG and NLU libraries instead of NLP libraries
This is because different libraries are
probably used for different specialisations.

A language translation engine could power a
de-ambiguator.

Perhaps I should start writing one in Haskell.

* Learn wolfram language better

* In order to go far in a job such as at one at facebook, I would need to have very, very strong general knowledge about the subject matter
In order to go far in a job such as at one at facebook, I would need to have:
- very, very strong general knowledge about the subject matter
- 

* Personal issues with Haskell
It's hard to test short segments of code.
This needs to be possible to make it easier to learn Haskell.

* I should be implementing NL parsers in haskell

* I'm actually really keen to get deep into Haskell parsing -- this will be so much fun

* My idea of latent natural languages
Legally, they are called ~Scène à faire~

French for ~scenes to be made~.

* I should be building towards a future where I need to working with many, many crazy powerful, expressive languages

* Yes I want to be working on better languages, writing higher quality code
I should give myself the opportunity to do so.

That being said, it's better to work on my
environment until I am comfortable stepping
out.

Also, higher quality code (in terms of
business) is not as important as writing in
more powerful languges.

* Yes I should be using file descriptors to link everything, including python scripts

* I must continue trying to increase my ability to understand things
This is the way forward.

For example, do not be scared of new
technology.

I must embrace it.

* It's important to be creating languages and IR tools
Otherwise, my environment will rot in terms of
how productive I am using it.

Also, focus on personal wellbeing and learning
something like Haskell -- getting great at it.

* I need to be learning much more resilient (difficult to automate) programming concepts in order to remain a programmer

* I should be aiming to enable myself to solve more problems as one day I will need to apply my skills to my physical self
But also to other people's wellbeing leading up to then.

* Make sure to smile a lot for photos at Josh's wedding
I should aim to be more happy around Nellie.

* I need to improve my ability to say happy birthday in as 'my-own-way' as possible

* I should push on with learning racket
** But remember to be building up my development environment
It's the key to helping me to learn things.

* If I want to be a programmer then I have to choose tools that are good for programming
It's as simple as that.

The fractal of knowledge grows larger but is self similar.

* It's perfectly OK to start dating someone else and break up immediately with the previous person
This is because I have good judgement.

I'm saving everybody time.

The onus is on me to stear the way.

It's also important to allow what was meant to
happen, to happen.

* I need more search in my emacs -- this is essential

* I need more AI in my emacs -- this is very important
But also more formal language.

* Yes, 2002 was a good year, but so is 2019
I have to aim to learn things about 2019 which I will remember fondly like the things in 2002.

* I have to be building awesome emacs tools

* I should be trying to implement these things in Haskell as I learn them
$NOTES/ws/random-number-generation/controlled.org

* Playgrounds are also for tools (such as gdb), not just libraries and languages

* TODO Fix spacemacs for c++. Everything else works well

* neovim is horrible -- never go there

* If I want I can sit on my current programming environment for a long time and become a specialist in legacy code
It might seem like old code will be around for
a long time but I'm sure that even the most
entrenched systems will be replaced.

* If I ever have to write code in a particular language, I should look into generating code of that language first

* I should simply work on emacs for a while, building into it the ability to run google searches and the like

* Someone needs to make an editior that is 100% code agnostic
Uses google search and deep learning only for finding documentation, for example.

Like an IR editor.

* Rust is the future of systems programming, C is the new Assembly
https://lwn.net/Articles/797828/

* It's a really good idea to get on board with reading God's word
It really is.

It's a very healthy thing to do.

* Since I'm only really using intero to compile and run actual projects, and not even with individual scripts, I don't need it on by default
I need to build up my snippets first.

* Keep learning command-line tools for editing different types of formats of things

* These text-based programs such as irssi will have aged too much eventually
I need to be holding =many= conversations.

* I should only support cheap things from now on. It's the only way
The sooner I start, the better.

* I am right about AI
https://www.theverge.com/2019/8/23/20830057/amazon-audible-speech-to-text-feature-lawsuit-major-book-publishers

* TODO automate lisp generation
#+BEGIN_SRC emacs-lisp :async :results verbatim drawer
  ;; Automate the process of generating this code -- do not do it manually
  ;; Use string filters
  ;; Combine lisp with a set of filters to generate the code
  ;; I must also remember the history of the manipulations I perform
  ;; Consider using yasnippet, but simple filter scripts or one-liners might be good enough
  
  Matrix Reloaded Soundtrack_The Passportal
  matrix mindfields
#+END_SRC

* Integrate more things into emacs
Going into tmux is often wasteful.

For example, if I want the emacs scriptsnames
and then to jump to them, I could make a tmux
binding, but that is wasteful when I can
simply stay in emacs.

* [#A] I should be building parsers so that I can be building new file formats to extend my glossary

* I'm not allowed to have a girlfriend until I free up time by wasting less time
I'm allowed to have a girlfriend as long as she makes me more productive.

* Learn more about parsing and generating code with haskell -- this is important

* Try to get good at solving classes of problems -- this is the ultimate expertise

* I must steamroll ahead. This is the only way, because solving problems is how to keep collecting more entropy
Try to collect as much entropy as I can.

* Stay close to the church. They will need AI guidance in the future

* Keep getting more abstract
It's important to start getting into haskell.

Hurry up and finish LYAH.

* I need more functions that have only single actions
For example, instead of searching for AND
playing something from youtube, have something
which searches only.

#+BEGIN_SRC sh :async :results verbatim drawer
  # surfraw youtube bad touch

  yt-search the bad touch
  pl the bad touch | yt-search
#+END_SRC

* Get stronger at programming

* I have to stay very strong. Do not fall over. Get stronger

* Make things that other people dont have, or simply try to understand and use things which other people dont understand or know how to use

* Get much deeper into languages such as haskell and racket, especially haskell
Haskell will be great at generating code in other languages, including natural language.

* I listened to this and it made me remember emotion
#+BEGIN_SRC emacs-lisp :async :results verbatim drawer
  (play-song "[[https://www.youtube.com/watch?v=9dmIzdegLzg][Turin Brakes - Fishing For A Dream - YouTube]]")
#+END_SRC

* emacs would make me great at c/c++
I could easily get a c/c++ job.

* I must continue improving my python, go and rust
Continue working on my emacs environment.

* TODO Commit to memory more (further numbers of) basic emacs operations bound to keys
** deselect region
#+BEGIN_SRC sh :async :results verbatim drawer
  vim +/"(define-key my-mode-map (kbd \"M-l E d\") (df deselect-i (deselect)))" "$EMACSD/config/my-editing.el"
#+END_SRC

* There is nothing that lazygit does right now that can help me

* TODO Only learn the oldest, most mainstream tools for their utility, then learn new stuff which fills the gaps
Also, DSLs are best.

* Do not compromise my practical skills
I need to upgrade them some more.

Move to turtle shell.

* If I get very good at haskell which is the skeleton then my mind should be able to fill in the gaps automatically
Getting good at a programming language is enough.

* Push much harder into haskell
I have to be building languages.

* I need to start an NLP company. Anything, really. It'll probably not go well at first.

* I should probably start contributing to some projects to keep my github account looking good
Make some github organisations.

* Become good at the Rust language

* Movies exist for my own entertainment. They will help me

* When it comes to improving my ability to edit code, the most important thing is to learn more programming languages
Learning programming theory actually does
help.

So does learning AI theory.

Learning these things will help me to navigate
the future world, make better decisions, be
less prone to becomming automated, but my
knowledge must be solid.

* The only way forward is to continue to improve my learning rate

* Do not encourage movie-watching, even though I have a soft spot for it, namely movies that I enjoy

* I must thoroughly go through the transformer stuff

* The future of programming is in generating language that I understand and then operating on that language
But manipulating text has to become something that I do as well.

* I really need to find a way to turn arbitrary code into sexp format
This would be very useful for me in terms of helping me to learn.

* It's not wrong to learn emacs and stuff. But I have to be fleshing them out by learning how to expand the medium on which these tools are expressive
For example, I must combine these tools with
knowledge of manipulating text.

Haskell may be the way.

It's a nice big net that is very expressive.

This is the kind of thing I should be aiming
to learn.

* Keep getting better at documentation in the terminal
Make commands like "vimhelp digraph-table".

Begin able to search for the history of things
is utter genious.

* This guy is smart. It is a good sign that I am learning haskell and language design
http://matt.might.net/

* I must become more focused with my learning

* All I really need to do to start a business is build something cool and show it to someone with money

* I must focus more on haskell

* Move into haskell exclusively
Composability is vitally important.

* haskell
It's OK to simply memorise haskelll
functions while the documentation and
tooling is terrible.

Because of composability.

* Lisp vs Haskell
https://chrisdone.com/posts/haskell-lisp-philosophy-difference/

| lang    | philosophy                 |
|---------+----------------------------|
| haskell | composability / UNIX       |
| lisp    | monolithism / kitchen-sink |

Haskell makes liberal use of composability
(the UNIX philosophy). Lisps do not.

Lisp functions tend to accept many options
which configure its behaviour.

Common Lisp composition is rarely if ever
used.

* If I want to learn python well I am already in a strong position to do so 

* Get much deeper into haskell
It's important that I'm building up my
haskell.

And learning new syntax.

* Get into parsing python, maybe

* Right now there are lots of jobs in c/c++ but one day a language is going to replace its status
Probably something like golang.

* Continue to build up my ability with regex and DSLs
And continue to integrate things.

This will inevitably lead to success and
starting my own company.

* I want everything to be readable
This is prioritised over things being in
consumable formats.

I prioritise regex for screen scraping
over things like json.

Everything must be done fuzzily.

** Get more into new types of regex, such as spacy's patterns

* Aim to get back into golang
Except when I get back into it I will have
completed "Ultimate Go".

#+BEGIN_SRC sh :async :results verbatim drawer
  vim +/"# Ultimate Go" "$MYGIT/hoanhan101/ultimate-go/README.md"
#+END_SRC

** I will have also make a bunch of fp snippets for golang

* DSLs are far more important to learn than these general purpose languages
Secretly, DSLs are more powerful.

For searching and refactoring code.

For describing problems not well suited to
these general purpose languages.

* I will not program in anything except for lisp-like lanugages

* Fuck deep learning. Simply get good at programming
Consider code as data and don't look back.

* There is no good defence against simply increasing abstraction
Why can be not continue increasing abstraction until there are no more problems?

* Start spending almost all of my time programming -- things will become infinitely easier if I decide to do this

* I must continue to do spacy stuff until I am actually building things with it
Always try to reach this point with anything I learn.

* I would only be hired as a programmer if it was a sacrifice for most people to do the work
This is why I have to be extremely good at my job.

* I must stay on top of emacs -- it will help me to learn and integrate information

* I could get very good at code generation if I become very good at yasnippet
For example, if I wanted to create a
tuple, I could not only generate the
syntax but also fill in the variables
programmatically.

* As a truly enlightened programmer, or as someone who is *learning* abstractly enough, it doesn't matter which language you program in

* Keep pushing for haskell

* Use yasnippets to learn, primarily
As a side effect I will have a great reference for actually writing code.

* Go deep into a projects
** haskell
** Spacy / problog
$MYGIT/mmxgn/sprl-spacy

* Learn more operators! -- this is super important!
I should probably try to learn at least 1 haskell operator a day.

* It would help to learn usages of a library rather than simply doing this spacy course
Learning how things are used properly shapes your perspective.

$MYGIT/mmxgn/sprl-spacy

* limitations of bash
** No method to get the type of this thing
#+BEGIN_SRC sh :async :results verbatim drawer
  [ -f <(echo hi) ]
#+END_SRC

* Use shanepy more
So I don't need to remember so much code.

Generating code would be better, but do
whatever is easiest.

shanepy makes everything easy so do that.

** Generate shanepy from hylang?
I should probably make a hylang shanepy.

* I need to become a lot more practical with parsers
Converting code.
Treating code as data.

* I have to be writing a lot more code
Take the shortest parth to achieving that.

It might be racket.

* Train yourself to think in languages
Part of the training is learning to use the search functions.

* I should stay in the ecosystem/editor which has the most function search tools
It's extremely important to build up
search functions.

It's like having a torch.

You can't program in the dark.

* Keep building up my emacs -- it's important to stay on top of it

* Definitely do not program in anything other than lisps
I have made my choice.

* Try harder to actually learn the code I am looking at

* Just get dirtier with my learning
Write all over everything.
The more I do that, the more optimistic I can be.

* I may need python3.7 for rasa
** I already have python3.7
#+BEGIN_SRC sh :async :results verbatim drawer
  conda-run ipython
#+END_SRC

* Ultimatelty, only the algorithms remain useful
Thinking about RasaNLU and spaCy.

* [#A] I shouldn't be learning things that a linter will pick up
Only learn things which a linter has no chance of picking up.
Automated code refactoring is an actual thing.

That being said, I still need to be actively practicing it.
I need to be able to read python.
The most important thing I should do is try to read code as well as possible.
The English language will almost certainly get a lot harder -- and more interactive.
I need to be able to learn English in the same way.

* Even if I mastered only one language, that would be enough
Mastery would be remaining the best though at that langauge, though.
It would be tonnes of work.

* I need to be copying documentation from spacy into yasnippets as I'm reading the docs
Copy every little thing I can.
Attempt to become quite good at spacy.

* It's actually really important to completely leave the confines of my programing environment and go deep into languages
Haskell, in particular.

* It's very important to be studying the spacy documentation

* I need to do more NLP stuff because...
The reality is that in the future competencey with natural language will
go far beyond understanding how to use the English language.

Already, we can see signs of it.
Lots of random startups.
Do we have to memorise all of these new words?

* Plan
** First get into spacy. Learn how to use it
Get some perspective on how to use the NLP libraries.
This is more important than knowing how to build the models myself.
Perspective is so important.
Also, practicality.

** Then master haskell
The type system is very important to understand.
Classifying algorithms is imperative.

* It's imperative that I move into a language with very strong types
I have to start thinking only about the types.
This is the way to understand how to program in the future.

* I should probably also learn to manage an erlang project
More important, however, I believe, is NLP and search.
Deep learning.

* It's very annoying there is no break/return in emacs lisp
But I can use errors.

* It's important to leave behind the english language and move deeply into Haskell
This is the smarter option.
Go deep into haskell and use its functions to model natural language.

* I must try harder and hard to do more abstract things programming-wise
This is extremely important.
I don't currently understand the real reasons why the most abstract things in category theory are useful.

* Keep in mind that I am in a precarious position
If my laptop were to die then I would be fucked.
I could in theory move to my new laptop with a separate keyboard.
The drivers are probably available now.

* What are the languages / libraries that I will rely -- truly rely on -- in the future?
** spaCy? -- probably not, but maybe if it continues to be popular and evolves
It will help me though to learn about an ecosystem of NLP models.
** TensorFlow? -- absolutely
** Erlang? -- maybe with LFE
** haskell? -- absolutely, but it will evolve into something different from what I expect

* The type of programming I will do in the future will be based on

Simply becoming better at editing text will be enough.

* Lots of things I actually do are codeless
https://morioh.com/p/5c29dd55b075

Don't get distracted.

Code is good.

But this makes it more obvious that I need
to get more abstract.

* Becomming good at spaCy and python is important, but not as important as haskell and emacs
language vs emacs?
Without bias, I would say language, but i have decided on and invested in emacs.

* I have to start thinking about programming things other than my own computer
What types of code (can I write that) are able to impact the world?

* Yes, much faster, cheaper and pervasive internet is going to be game-changing

* I do need to be better at the languages themselves and the tooling for those languages -- try to push this to extremes
Then I won't need to use google so much to find things.

** For example:
*** Generate urls
**** forks -- add /network/members
https://github.com/ines/spacy-course/network/members

* TODO I have to rely far more on the actual language to do things
** But annoyingly this doesn't override the definitions
#+BEGIN_SRC python :async :results verbatim drawer
  source_file("/home/shane/var/smulliga/source/git/mullikine/shanepy/shanepy.py")
#+END_SRC

** emacs itself is not as important as simply becoming great at a language.

* [#C] AI life lessons
[[https://www.youtube.com/watch?v=KhP7lTLTipc][6 Life Lessons I Learned From AI Research - YouTube]]

* [#A] I should read code, bring up documentation, and make snippets as I am discovering useful code snippets
This is a very effective way to learn to program.

* I should be trying to become good at working with the language python and its ecosystem
One day I will need to be able to hack on python to fix things at home.

* [#A] I know how easy it is to make my own functions
I need to commit to memory premade functions at a much faster speed.

Write them down and remember them.

Develop a process for learning functions.

* I write in Hylang from now on and never python
Getting better at emacs and creating environments for languages is better than improving my python.

* Get good at hylang and building hylang tools. Why not.

* Consider that it would be a lot easier to create a programming language if I knew a lot of functional programming in the language

* Never make snippets in anything except lisps embedded in other languages

* It's important to be generating functions
Use letters as if they are decision trees.

This way I can generate many functions.

It will be great.

* Yes, I must build up my collection of snippets
It must be completed.
Make it even easier to create snippets.

* It's time to foculs
Focus is very important.
I must also be solving problems in the correct way.

** Focus on this spacy code

* Yes, I've been doing so good python learning
But I need to put more focus on mastering haskell.

* I must concern myself with python
Take it seriously.

Don't get too distracted.

Python is important.

* The things I am learning now have to be passive skills
Passive skills are skills that will be important no matter what job I am in in the future.

* Seriously, I need to be programming in racket and haskell
Code generation is important.

Code generation combined with reasoning and debugging ability.

* I need to focus as much as I can on improving my haskell
The more focus I have, the less time I will waste reinventing the wheel.

* One day *knowing* a programming language will basically mean having at muscle memory tonnes and tonnes of useful functions

* There is a lot of merit in focusing on one language
I should definitely do this more.

* Can I learn to build sideways instead of from the ground up?
Which languages would allow me to do so?

* I must be *thinking* in python
And *thinking* in haskell.
In order to do this I must simply do more of those languages.
It's time to specialise.

** Also think in NLP
** But also thinking in problem solving! -- how to solve classes of problems e.g. SAT/SMT.

* I must escape the churn -- enter into a language that can support the abstraction I need
I need to fall on haskell because it has the strongest abstraction.

* Everyone is feeling the pressure of AI
People who program in Go -- I should support them rather that mock their language.

* It may be important to actually do a lot of math on the terminal
Consider this and come up with ways of properly doing math.
Math in haskell?

* The best abstraction is moving entirely to into a language

* It's important to get into spacy and integrate it
Otherwise, I will find that younger
programmers will simply have tools that
don't exist for my stupid self.

** Tools such as ~token-pos-dep~ will help me to get perspective
Make ~interactive~ functions for emacs as wrappers around filter scripts.
By default they should take the region, but if that's not available it should ask for some input which I manually enter.

#+BEGIN_SRC sh :async :results verbatim drawer
  token-pos-dep
#+END_SRC

* It's important to continue abstracting things away
I must abstract away my entire
environment.

Abstract away my programming environment.

How?

* haskell is how I stay sane -- it's very important

* It's imperative that I get into haskell
Python simply doesn't have the abstraction we need.

** [#A] My haskell programming must also be very easy
I *must* get into haskell in a big way and make it easy.

* It's important to move into haskell and the ~yi~ editor
Because I want to be solving problems in haskell rather than other languages.

* It's important to understand this stuff
https://www.youtube.com/watch?v=SMj-n2f7wYY

Continue to try to improve my ability to learn.
Yes, use the transcript more.

Never use youtube without the transcript.

* I have to be building AI tools
This is the only thing that will put me in the mindset that I need to be in.

I also have to be programming in haskell.

** [#A] Finish this video!
https://www.youtube.com/watch?v=SMj-n2f7wYY

* This short program is a perfect example of a snippet for Matcher
$MYGIT/ines/spacy-course/exercises/solution_01_11.py

This is actually how I should implement snippets.

* I must build my own operating system/environment within a language such as haskell

* Do not upgrade my computer! Ever.
Keep learning haskell with it.
One day in the far future I may take my emacs and port it to a new futuristic operating system.
Dont upgrade my ubuntu computer -- even for new tensorflow stuff.
Not even for spacy.

* emacs
** Do more macro-oriented emacs lisp programming
*** [#A] open-next-file
| kb          | f              |
|-------------+----------------|
| M-l M-n M-n | open-next-file |

**** Both the macro and programmatic versions work
#+BEGIN_SRC emacs-lisp :async :results verbatim drawer
  (defun open-next-file ()
    (interactive)
    (ekm "M-m f d <up> RET")
    ;; (let ((next-file (e/chomp (sh-notty (concat "next-file " (e/q (basename (current-file-name)))) nil (current-dir-name)))))
    ;;   (find-file next-file))
    )
  
  (defun open-prev-file ()
    (interactive)
    (ekm "M-m f d <down> RET")
    ;; (let ((prev-file (e/chomp (sh-notty (concat "prev-file " (e/q (basename (current-file-name)))) nil (current-dir-name)))))
    ;;   (find-file prev-file))
    )
#+END_SRC

* Get good at spacy by reading all those solution files
Focus on my learning.

* Continue to learn DSLs
Continue to do programming.
Yes, my operating system will be built on DSLs.

* I should be trying to become good at describing things too
Classifying with the transformer.

* It actually is very important to remain connected to environments like emacs but cloud ecosystems

* emacs must become my happy place
I must exhude freedom and peace.

* Simply get better at searching for stuff I want
Quicker at it.

* Need to be able to clean up text by searching for things in the text I want to change (such as a URL) and then applying a filter to that thing
I should learn spacy to get good at this as fast as possible.

* It's actually very important to become and remain *good* at python
** Make a command to automatically download the models for a given python script
#+BEGIN_SRC sh :async :results verbatim drawer
  msudo python3.6 -m spacy download en_core_web_md
#+END_SRC

* I shouldn't try to reinvent everything
I must float.

* Relying on scripts I understand, written in bash, I can only get so far
If there is a maximum number of variables I can hold in my head, they should be in high-level language.

* It's important to become good at high-level languages
I think I need more power when it comes to building terminal programs.
** For example, ~cl-simple-tmux-error-detect~.

* Keep getting better at python

* Nellie is actually extremely mature for her age -- seriously don't underestimate her

* It's absolutely essential that I stick closely to python

* Only install as much as I need to learn the things I need to learn

* It might be hard to understand but I truly do need to be doing more NLP stuff

* I need better navigation for NLP stuff
The only way to do this is through models.
One day models will be easier to hide from people for sure because there won't be enough NLP scientists.
At that stage, my terminal environment may break down.

* I must start reading academic papers more and trying to digest more information
I have to start integrating maths into my environment so that it's easy, not just to write down, but to experiment with.

* Really question how important it is to deliver arbitrary facts to Nellie

* I need to remain good at learning
What is the next YouTube?
It definitely will have roots in NLP.
And most likely it will be built into YouTube.

* Need to dig really deeply into haskell -- it's the only way

* Whatever I do on the computer, I must be exceptionally good at it
For me, it needs to be manipulating text.
After that, I need to ensure I am working
in languages such as haskell, to ensure
the longetivity of whatever I know.

* Actively improving my Python and Haskell skills are very important

* [#A] I have to remain competent at AI and functional programming -- this is very important
Learn math.
Yes I have to be able to exhaust regex solutions.

* It's important to be able to search for example source code. TabNine Cloud isnt good enough yet for getting very specific

* Do I think that M-SPC == just-one-space is useful? I've never found the need for it before

* I must be programming all the time in order for myself to get jobs doing it

* Spend more time doing actual python

* I should collect lots of python lambdas, as I do with filters
** last n elements
#+BEGIN_SRC python :async :results verbatim drawer
  # I have this
  nlp.vocab.morphology.strings.__len__()
#+END_SRC

** List of python lambdas
$NOTES/ws/lambdas/python.py

* Consider hacking on ptpython
I can already add key bindings -- this is what's important.
#+BEGIN_SRC sh :async :results verbatim drawer
  sp +/"@repl.add_key_binding('j', 'j', filter=ViInsertMode())" "$HOME/.ptpython/config.py"
#+END_SRC

* I want to know the types of the things I am typing out
I need key bindings to display types and things -- rather than manually entering code all the time.

* Consider learning Maxima

* Focus on search
#+BEGIN_SRC sh :async :results verbatim drawer
  sp-awesome-search functional python
#+END_SRC

* [#A] Only use productivity increasing languages -- never use subordinating languages (such as Go)
Get to expert-level haskell by learning productivity-increasing languages.

* Seriously need to improve my python -- I can do it

* Use spaCy as a way to get competent at Python
After that I must get competent at Keras.

* Before I streamline my emacs doc bindings any further, simply work a bit more on python
Stay abstract.
Get into code analysers.

* It's really important to merge my environment with the python / keras / spacy ecosystem

* If I want to become super good at NLP then I should definitely get familiar with spaCy
And python. I want to build stuff.

This is short-term NLP.
It's still important.

* Perspective -- I'm not sure on Nellie

* If I don't want to turn completely into a data scientist then I need to be building a functional programming tower

* Keep integrating
If I don't start then I'll always be living in crazy world.
I must resist as hard as I can until I am generating, indexing and searching code and NLP.

* I should be generating all of the code I write
Makefiles are supposed to be easy to write.
If they are not easy then they should be generated.

* Simply stop programming in so many languages
I need to focus on the mother languages.

* I have to get good at haskell
It's a precursor to becomming good at NLP.

* Absolutely must continue with emacs and get good at it. I can't rely on a girl to make me happy

* I wouldn't be having problems with syntax getting in the way if I were writing in a language with more flexible syntax, such as lisp

* learning haskell
In order to master haskell I probably need to master the type system.

** Really try to learn haskell well -- it'll be worth it
https://wiki.haskell.org/Keywords#forall

* Accumulate functions such as these -- is that actually a good thing to do?
#+BEGIN_SRC sh :async :results verbatim drawer
  mpv --ytdl-format=worst  'ytdl://ytsearch: sandy frank godzilla full movie'
#+END_SRC

Such endeavours are not important compared to learning haskell.

* I need parsers
For practically everything.
In order to achieve this I need haskell.
Haskell is going to make my emacs very amazing.

* Attempt to master haskell before PureScript
I like the old languages.
Bash has definitely not let me down.

* This is the type of thing I should be learning -- become good at both haskell and data science
https://tweag.github.io/HaskellR/

This is how it's done.

* Perl is annoying with its warnings
#+BEGIN_SRC sh :async
  vim +/"use Text::Tabulate;" "$HOME/scripts/tabulate"
#+END_SRC

* Can program in R using haskell
https://tweag.github.io/HaskellR/

* Spend my time actually building things in haskell

* I have to build up my haskell
This is the actual way to get super strong at programming.
I can build a very large tower with haskell.

* Try to focus more on haskell so when better tooling arrives I will be an expert

* Kim Mensing
$NOTES/ws/music/discovery.sh

* If I were to simply become good at AI detection, that would be amazing!
That's a job in itself.
But you have to understand the language these AI researchers are using.

* I must become expert at haskell
I could be becoming an expert at python but it's better in the long run to go for Haskell.
Python syntax is simply too simplistic.
It's for noobs.
Maybe I can write python and generate haskell one day, though.
Haskell is more important.

* Use dates that point to the time that I discovered it, rather than the actual date it was published
#+BEGIN_SRC sh :async
  vim +/"\* Mon 29 Jul 2019 18:06:49 NZST" "$NOTES/ws/nlp-natural-language-processing/understanding.org"
#+END_SRC

* Try to do less actual emacs and more learning
It's likely that emacs will be updated beyond belief.

* TODO In order to actually work in a job where I do TensorFlow, I must be able to do it well

* Continue making functions such as this
#+BEGIN_SRC emacs-lisp :async
  (defun get-yt-playlist-json (path)
    (interactive (list (read-string "path:")))

    (if (string-empty-p path) (setq path "[[https://www.youtube.com/playlist?list=PLGYGe2PKknX2kydiv28aq8dBXBWeJfxgg][The Lion King 2019 soundtrack - YouTube]]"))

    (let ((result (e/chomp (sh-notty (concat "ci yt-playlist-json " (e/q path))))))
      (if (called-interactively-p 'any)
          ;; (message result)
          (new-buffer-from-string result)
        result)))
#+END_SRC

* PureScript isn't ready
Continue learning haskell and doing NLP.

* Continually make stronger and stronger search functions

* TODO Make reading TODO lists such as this
#+BEGIN_SRC org :async
  * TODO read and understand these
  ** done
  ** left todo
  $MYGIT/ines/spacy-course/exercises/solution_01_02_01.py
  $MYGIT/ines/spacy-course/exercises/solution_01_02_02.py
  $MYGIT/ines/spacy-course/exercises/solution_01_02_03.py
  $MYGIT/ines/spacy-course/exercises/solution_01_03_01.py
  $MYGIT/ines/spacy-course/exercises/solution_01_03_02.py
  $MYGIT/ines/spacy-course/exercises/solution_01_04.py
  $MYGIT/ines/spacy-course/exercises/solution_01_07.py
#+END_SRC

* I have to be using the programming languages I know to get better at NLP
This is very important.

* Try to program exclusively in the language I want to get good at
I have to focus a bit more on haskell (or purescript).
Focus on building languages, syntax.
But before that, try to simply build some things in those languages.
But before that, make sure I have a decent environment for programming.

** Plan (in order)
*** [#A] improve / streamline emacs environment
*** build some basic stuff in haskell
*** move to purescript

* I should be making unified parsers to do things like opening links -- to become a skilled programmer
Pattern matching.
But ultimately I should be doing pattern matching with deep learning.
Combined with classification by APIs.

* If I don't continually abstract my environment then all of a sudden emacs is going to become quite difficult
Right now I feel on top of it but in the future I may not.

* It's actually extremely important to be writing code in a lasting way

* I'm very close -- all I need to do is continue doing what I'm doing
I'm going to get a crazy awesome job.
I will start doing NLP in my terminal and the rest is history.

* Get as good as I can at
- python
- text preprocessing
- emacs
- haskell
- problog

* TODO This is so easy to read -- start using the transformer / gpt-2
$NOTES/ws/huggingface/quickstart.org

* If I do not focus on languages such as haskell then the future will get very confusing
I will find that I can look up code in order to understand how the world works.

* I must become better at string manipulation
I can use emacs to do this.
But I must use emacs to become good at other languages.

- haskell
- racket

* Do my best to keep everything inside emacs
Genuinely, I should be trying to put everything inside emacs.
Can I pull it all in and leave my old environment behind?

* The faster I can complete my emacs TODOs the better at emacs I must be
Yes, it's extremely important to become better at emacs.

* Honestly, just keep doing emacs -- it's clearly important
Every now and then I should run emacs in its own GUI to be blown away by it.

* [#A] Consider making my career in Haskell

* It would be really nice to be able to generate problog
I should simply be making functions in lisp.

* Keep integrating things into my emacs
Ideally I should very rarely actually interact with emacs.
It serves its purpose as a skeleton-like thing.

* It really is more important to simply learn high level language syntax
Because I don't know what I'll need to apply that knowledge to in the future.
Syntax is the knowledge that lasts.

* It's possible that people are too distracted to pray properly

* In the future there will be a lot more autocompletion and inference and it's more important to simply know the languages
That being said, it would still be incredibly powerful to build your own environment.
But I would need to get extremely absorbed in it to ensure my way works against alternatives.

* OK, try to master emacs to a good enough level and then try hard to learn haskell
Try to apply haskell to IR and NLP.
Integrate.
Try to apply myself.
Ensure the code I learn is abstract enough that it remains relevant.

* I have to constantly lower my opinion of my own abilities
And aim to do more.
It's 'visionary' or die.

* It *is* correct to pursue the most abstract programming language
I want my learning to entail deep learning.
Functional programming with haskell can do this.

* I must continually improve my python environment
** It's totally worth learning fast navigation bindings for python
Seriously!
In fact, I probably *should* be doing that.
Anything to do with improving my meta-programming is high priority.

*** Navigation must be easy
*** elisp must be easy

* The way to deal with increasing complexity is to abstract in advance

* Learning haskell is more important than spaCy
It's almost a prerequisite.

* The faster that emacs evolves the better
Try and keep with it and learn as much as I can along the way.

* The fastest way to get better at code is to simply read a lot of it

* Simply continue getting better at emacs

* My environment must become very meta -- fast
Consider that the fastest way to achieve this is to simply learn a language properly.

Yes, get better at python.
But it's truly all about the text.
It's all about the language.

* I need history for ~all~ the functions I use and want to recall the history of

* Don't be deceived into going all-in on deep learning without integrating
It's all useless unless it's integrated.

* Fuck Django -- it was absolutely a waste of time anyway
I can think of nothing would rather do less.

* Continue improving my environment
More important though is making my stuff
relevant to people.

The way to do this is by getting good at
something.

* I want to be able to expand lists of globs, efficiently
Therefore, I need to do it in a language like racket.
It's important to not sub[shell] out for every single thing.

$EMACSD/packages26/yasnippet-snippets-*/snippets

* I should take reading the bible seriously. It helps

* My CV must be an experience for people
Not merely a document.

* Try to get better at simply reading websites and processing them through spaCy

* I must build search tools that link arxiv stuff to other things

* Better than snippets are making related aggregations of code
#+BEGIN_SRC sh
  vim +/"\* emacs lisp" "$NOTES/remember.org"
#+END_SRC

* Need to make an environment for programming with TensorFlow
$MYGIT/tensorflow/addons

Is this just my playground?
I probably need to make emacs modes.

* Need to become better at string manipulation
- emacs is great

* I do not want to give up on YA
Going out with a bang is far more
important.

It's half-way through the year already.

* It's far more important to be writing in haskell and racket than learning random tools such as hub
This is because of what languages like
racket will become, for me, in the future.

* Start using GPT-2 for things
Need an environment to actually use GPT-2.
What abilities do these pretrained weights unlock?
Perhaps spaCy will package it up.
Something must.

* It would require commitment to learn racket to the point where it beats bash for extending the language
I need to learn the syntax transformers.

Do the course.

https://school.racket-lang.org/2019/plan/index.html
https://school.racket-lang.org/2019/plan/mon-mor-lab.html

* TODO [#A] I need a more powerful scripting language
Ruby is probably a lot better.

Need the ability to perform the same kinds
of matches on both pipes and on string
provided by argument.

I should simply memorise some functional
bash.

#+BEGIN_SRC sh
  vim +/"\* functional bash" "$NOTES/remember.org"
#+END_SRC

** functional bash
#+BEGIN_SRC sh
  apply "grep -q '^http'" "http://arxiv.org/pdf/cmp-lg/9708013v1"
#+END_SRC

* I may have to entirely abandon my environment and go full-haskell
Or consider going full-python.

Or both.

Just do what's easiest for the task at
hand.

If I focus on one task, such as IR, NLP or
DSLs, I will get truly strong at it and
that will help me elsewhere.

* One day we'll have a fuzzy terminal interface
Like ~browsh~.
Therefore, the terminal definitely has a lifetime.
It means that creating very abstract things to do with language is very important.

** [#A] I have to be great at parsers.
- probabilistic
  - inferring from very little information
- learned
- haskell
- code

*** TODO [#A] I must obtain more parsers
This is absolutely vital.
Where do I search for parsers?

* Try to increase the speed at which I learn things
** languages
Use org-brain.
I also have to be able to search org-brain.

* I need to focus on IR for a bit -- and study more NLP parsers (take active steps towards learning NLP parsers)
** How can I get lists of git tricks? -- I want to be able to ask for it
*** git: pushing to a remote branch with a different name
#+BEGIN_SRC sh
  git push origin local-name:remote-name
#+END_SRC

#+BEGIN_SRC sh
  vim +/"\* git: pushing to a remote branch with a different name" "$NOTES/ws/git/remember.org"
#+END_SRC

* Keep mullikine.github.io private
Build a new face for my github website.
Master org files.
Master emacs.
Everything must go through emacs.
This is how I will stay strong.

Offload languages such as racket onto emacs.
Integrate.
Build emacs modes.

* TODO Start writing or at least consolidating documents on best practices
This will demonstrate that I'm an expert.

Building learning tools will get me to a job where I am some kind of consultant or CTO.
In fact, I probably *should* try to get a CTO job.

* Most people in AI jobs will get chewed up and spit back out
Don't be this kind of person.

* Spend more time actually learning libraries
I must learn things like rules of thumb on the side.
Only when I have become sufficiently good
at both something like Keras and the
theory of DL can I actually start making
things.

* I have to make my learning more meaningful and efficient
Always learn something when I read something -- make this a rule of thumb for learning.

* emacs lisp is fun but I really need to concentrate more on deep learning
My environment is not really good enough.
First master snippets and code gen in emacs lisp and racket.
This is important as a precursor to generating python code.

* It's pretty important to lean more heavily onto proper languages
It's time to upgrade to such things.
Learning racket properly is important -- vital actually.
Also, python libraries such as Keras are important.

My exponential progression should be as strong as the world's.
I need to be capitalising / expontentially improving in some way.
Lean on my language for this.
This means I must study something like racket as well as I can.

* It is actually important to integrate NLP
Just look at this stuff.
It's incredibly important to integrate NLP.
But not just integrate; continue learning stuff which will make me a better programmer. NLP and IR.

https://waifulabs.com/

* I need to capitalise on my AI cleaning-up skills in order to read the bible more effectively

* Spend more time getting even better at my tooling
Lean more heavily on haskell.

* Having made my own libraries in python is not good enough
I actually need to use my own libraries to do more things.

** What's truly important
*** Building my FUSE filesystem
*** Building more search functions
*** Streamlining emacs
*** Building a spacy environment

* I used to think that learning syntax mattered more than deep learning. I was probably wrong
It might be worth my time to learn the most abstract Deep Learning libraries.

* I should find other learning material for other things I want to learn
That means github repositories.

For example, if I want to learn haskell things I should look at some haskell example code.
Start nice and simple. Work my way up to greater complexity.

* I should try harder to do things the easy way
If I make myself too outstanding then life will be harder.
I can, however, simply be an awesome programmer.

* Just keep learning how to do Deep Learning
This is far more important than actually training anything.

* Say goodbye to Health Science forever
Fully commit to Deep Learning.

* Continue learning and building productivity tools for learning more effectively
Integrating NLP and search stuff is more important than learning Keras.

* I can now start populating this list with either shell or emacs lisp
$HOME/filters/emacs-lisp-functions.txt

* push emacs further and further

* emacs is essesntial to learning deep learning
Seriously, it all seems possible now.
I can learn again.

* Just get good at Keras
High level is best. I need to learn from the top down.

* It doesn't really matter where I end up. I'm so skilled if I demonstrate some Deep Learning then someone will simply place me somewhere

* I once again find myself needing to learn TensorFlow again
I have to understand Deep Learning.
TensorFlow is a platform to assist me in doing that.

* My own machine is primarily a learning environment

* Use the computer to solidify my knowledge
Build up trees of things.
Offload more and more of my thinking onto the computer. It's the only way.

* TODO I have to get practical with my NLP and IR
This is very important.
Get practical.
+ That means figure out which are the best libraries for doing:
  - LSA
  - LDA

Well I just need to be able to do them.
If I am practicing it then I will have a better idea.

* I need to become more convincing
In order to do this I must start doing NLP on myself.
Make things with spaCy and Keras.
Turn them into tools.
Don't forget, integrating tools into my environment is also ESSENTIAL.

* I must get a lot better at python. Not a little bit, a lot.
But it's more important to develop my own search tools.
And work on things like filesystems and NLP.
NLP is probably the most essential thing.
But long-term, it's probably abstract Deep Learning concepts.

* Ultimately I want to be generating stuff with Deep Learning
This should be first priority.
Becoming a super expert on emacs plugins is a 2nd priority.

For example, I can generate the ~org-brain~ graphs.
This is a better goal. It's abstract enough.

* Make Deep Learning environments
It's healthy to maintain an amount of learning in this area.

* If I make my glossaries in org-mode then I should be able to get documentation by running the doc keybindings inside of a babel block
It's true.
I should probably be doing this.
I must continue to compose languages.

* Keep in mind that deep learning will make my editing much more efficient
Manually writing out words should be very high entropy.
+ This is why I must continue:
  - Installing plugins for emacs
  - Pushing natural language
  - Searching out NL editing tools for the terminal
  - Integrating NLP into my environment

* Applying for jobs
It's not necessary to have years of experience with a programming language.
Because the libraries are what matters.
Have you learned the new libraries.
It's all about the application of the language.

* Building codes is how I get more abstract
Everyone needs to build things that are so personalised they are hard to understand for others.
You have to get to that level.
Building my own languages is how I will do this for myself.
It's possible that pure Deep Learning is the only way to get there.

* Keep building tools for emacs to integrate NLP libraries

* Keep getting better at emacs
It's the ultimate way to upskill while I wait for something.

* Start pushing into NLP
Am I able to use a GPT-2 model to create a programming language?

* It's probably actually important to get good at creating programming languages

* Continue improving my emacs
It's essential that I get really, really, good at at emacs / what I do.

* Maybe from humble beginnings I should simply try to understand tensorflow well before attempting to understand these repos
#+BEGIN_SRC sh
  vim +/"with tf.Graph().as_default():" "$MYGIT/tensorflow/ranking/tensorflow_ranking/python/losses_test.py"
#+END_SRC

* I must continue to improve my emacs environment
But I must also use emacs to become good at python.
The task of improving my python will help me to make better decisions when extending emacs.

* The way to stay smart is not to get too deep with anything
An AI future means we only need to know our way around things.

* Search functions are so important
Continue making search functions.
Build abstractions.
Learn more heavily on languages that will stand the test of time (such as haskell).

* TODO Make a command for searching all these files for example source code
$HOME/notes/ws/search-lists/spacy.txt

Also allow directories.

Should I write the code in racket/haskell or a better language than shell?
Only if I actually knew the language.
Learning racket/haskell will pay off eventually.

* Simply get better at python for a while

* Keep moving towards using and understanding GPT-2

* Keep learning to use GPT-2
Fuck the job market.
Remain in denial of all that bullshit.

* Questions for spaCy
** What can spaCy give me in terms of Deep Learning?

** What can spaCy give me in terms of NLU?

* Try to get better at building repls in emacs

* When a new emacs frame is created, the indent highlighting resets

* Learn more racket
#+BEGIN_SRC sh
  rkt -e "(displayln (join-lines (map str (glob \"/*\"))))"
#+END_SRC

Offload more and more onto racket.

* [#A] One day, perhaps soon, I will be programming in the code interlingua
Either that or it will be fairly easy to generate one language from another.
In that case, I would want to be programming in th emost popular language.

* It's possible to use python2.7 libraries in PyonR (python on racket)
$MYGIT/pedropramos/PyonR

* I only want to learn the language-building syntax stuff in racket
I don't care about doing linear algebra.

* In all seriousness, work out how to do this
https://tabnine.com/semantic

Don't forget to focus on tools.

* Keep learning language syntax
Learn language syntax as much as possible.

* Get more into NLP autocompletion

* It's important to try to learn to write in these languages
https://cheats.rs/

* Do not try too hard to get good at python
It's important that I get good at meta stuff.

* NVIDIA predict a 1000x increase in GPU speed by 2025

* I have to be learning about learned index structures
I have to be training them in the future.

* The Moon
Projecting forward, there will come a day about 50 billion years from
now when the Moon’s orbit will reach its maximum size. At that point,
one lunar orbit (one month) will take 47 days. Earth’s rotation period
will also be 47 days, meaning that one side of the Earth will face the
Moon at all times, just as one side of the Moon currently faces the
Earth at all times. With the whole system synchronized, the Earth and
Moon will no longer have any tidal effects on each other, and the Moon
will stop moving away.

* integrated DSLs -- surely this is the future
#+BEGIN_SRC sh
  ifl integrated dsls haskell
  ifl integrated dsls python
#+END_SRC

Keep in mind that a DSL which does not convert into the host language is not a very good DSL.

* Keep learning language syntax
** Haskell
This is possibly the most important language to continue learning.

** python
Surely, DSLs will be integrated into python.

** jq
$HOME/notes/ws/jq/scratch.jq

jq may be a waste of time if I can simply learn more haskell.

* Keep integrating things into emacs
Keep on abstracting.
One day it will all pay off.

* I need to get momentum
Keep going with building up emacs and python for a while.

* I need to make progress to what I am trying to do

* I only need to learn how to read various languages
That should be the first thing I try and learn.

* I just need to learn high-level python stuff

* Search is by far more important than going through tutorials
Continue improving search.

* TODO try to understand this document
https://www.tensorflow.org/extras/candidate_sampling.pdf

* How to get good at haskell

* I should aim to get good at ~stacks~

* It's probably better to learn haskell concepts over others (such as R-lang) 
Because I can then give names to

* R language
- has a piping concept akin to unix

https://www.datacamp.com/community/tutorials/pipe-r-tutorial

* Keep on integrating things into my own environmen
This is the way.
There is no real upper-limit.
Just believe.

* It's important to get deep into programming language ecosystems
If you don't go deep it can be difficult to find answers to google queries such as:
- linux productivity tools
  Looking for things like ranger.

The reason is these tools may not be specific to linux.

* Need to be able to use Python as a wrapper around my shell scripts
This is really important.
Take control of my operating system with python.

* I need to focus on projects which I feel are important and I should learn about them
$HOME/notes/ws/github-semantic/glossary.txt

* It might be important to simply become very good at python

* Keep improving environment. Unlock new languages

* Focus more on deep learning, spacy

* [#A] I seriously need to get better at python
anaconda-mode is lifechanging.
It can turn emacs into a great python environment.

* It is very important to incorporate deep learning into my environment

* I should be learning more high-level haskell syntax
Only if I do that will I truly be abstracting enough away from the computer.

* It's really important to get good at internet search until I'm 

* It's extremely important to either dominate at a mainstream language like Python
Or set myself up for the future with haskell or deep learning.

* All the tools I use must be abstracted away
Yes I must use anaconda because I need to learn its search functions.

And I need a stable environment for writing Python.

* Spend a little time simply reading the emacs info pages
Some plugins happen to come with documentation that is automatically loaded.

| kb      | f    |
|---------+------|
| C-c h i | info |

* My programming environment is primarily for learning
It's a learning environment that doubles as a programming environment.

I should be actively doing machine learning on my own environment.

I should actually be building models for similar purposes as taking notes.

To help me to learn.

* fp must be trampoline for search
I need concepts like 'functional programming' to be line trapolines for
searching for such concepts in any language

* Learn introspective functions which compose
#+BEGIN_SRC python
  d(d)
#+END_SRC

Learn as many of these kinds of functions
as I can.

It's essential for learning a new
language.

* TODO Use org-brain to remember things
- awesome

** TODO [#A] make more concept maps
Right now I only have one big map.

I need to make arbitraily many maps.

#+BEGIN_SRC sh
  # Put emacs as the selected entry
  org-brain emacs
#+END_SRC

* No, haskell isn't perfect
But it's pretty damn good.

Learn it.

* More important than search is the ability to learn anything
We have google.

We can find the information we need.

Now we only need to read that bit of
information and learn it.

* It's probably not worth learning python overly well
I don't care who wants me to program. I should only learn enough to make changes.

* Functional programming is the true glue code
bash is terrible code.

But functional languages such as haskell seem to be very early.
Perhaps purescript is the future?

* TODO I must get better at all kinds of search
#+BEGIN_SRC sh
  awesome-search functional python
  awesome-open https://github.com/SwapneelM/awesome-particle-physics-for-non-physicists
#+END_SRC

* Any particular python library does not matter at all
I only need to learn tools for reflection, search and code generation/manipulation.

* I need to be learning things which are still useful if I lose everything

* It's actually very important that I master the tools I am using
- ~org-brain~
- TensorFlow

I have to master the high-level tools to prevent code-rot.

* Consider removing my notes repository from github

* I have to keep learning despite my programming environment getting older

* It's vital to create my own job

* In all seriousness, maybe I need a better python editor
hmmm. Nah, just work on shanepy.

* It's important to be able to read and understand different languages such as
- stoichiometry

** But then, the most important thing is to get better at learning and retention
I should do some natural language understanding.

* I need more powerful emacs and/or zsh bindings for extracting things from a repl
** TODO Make a command for zsh to copy the interior of the first string
These string functions I am accumulating must be made into haskell functions. That is important.

* It's all about understanding programming languages and using them to operate my computer

* Learn more DSL-like programming languages
They are useful, conceptually -- and will be useful in the future.

- prolog
- problog

* My development environment should be capable of developing anything
Remember, the objective is not to look pretty but to manage lots of things.
It's a shell to everything.

* All of my programming has to lead to learning
Learning is by far the most important thing I need to be doing.

* Deep learning classification for text is immensely important for my programming environment
Generation is probably quite important too.
Both of these things are extremely important.

It's more important than learning new langauges, unless the languages describe the classification and generation operations I want.

* I need to read more subtitles and do more study
This is more important than anything else.
It's more important than learning tools.

I must understand things at a higher level than others.

* It's actually very important to get better at NLP with tensorflow and spacy
Seriously. Real jobs will rely less and less on my own environment and require me to know these very abstract systems.
That being said, I need to try to create my own job.
In the future I will create my own job based on my skillset.

* Do more study
I need to actually focus more on NLP.
This means

* Need to start relying more on particular libraries to keep myself up-to-date

* My learning rate must increase

* Types will become very important in the future

* I must develop code completion tools

* Don't lose my cool
I must remain focused on becoming an amazing developer.

* Haskell is the best language for AI
#+BEGIN_SRC sh
  ewwlinks +/"AI Will be Everywhere..." "https://mmhaskell.com/blog/2017/8/7/the-future-is-functional-haskell-and-the-ai-native-world"
#+END_SRC

** Pure, Functional Programming is the Path to Safety
#+BEGIN_SRC sh
  ewwlinks +/"Pure, Functional Programming is the Path to Safety" "https://mmhaskell.com/blog/2017/8/7/the-future-is-functional-haskell-and-the-ai-native-world"
#+END_SRC

* Languages such as python are not the future of programming
Surely they are not.
They are not DSL-like.
They are pretty languages.

* Build a fuse filesystem -- keep extending it. Capitalise
I should start building a nice filesystem to start to capitalise on everything.

* Really need to be building more abstract search functions
More abstraction. Hurry and use the fuse filesystems.

* I need to be able to jump to functions in all languages
Maybe not per-project, but definitely per-global-language-project.

+ Checklist [2/2]
  - [X] bash
  - [X] emacs lisp
  - [ ] haskell
  - [ ] racket

* I have to find my passion and go for it
My passion is languages.

* Don't derail myself by getting too deep in a language such as haskell
Honestly, I don't think I could do that anyway.

Perhaps I should be doing more decentralised stuff such as TensorFlow on the cloud.

* TODO I need to flesh out reflection on all the languages I use
** racket
https://docs.racket-lang.org/guide/reflection.html

From the perspective of the core Racket
run-time system, all evaluation is
reflective.

** haskell
http://hackage.haskell.org/package/reflection-2.1.4/docs/Data-Reflection.html

The Data.Reflection package.

* The most important thing is to continue learning concepts
More and more abstract concepts.

* Try to minimise the amount of time I spend in front of a screen, compared with the amount of time I spend learning
Learning abstraction that is as pure as possible is extremely important.

* Yes, use yasnippets a lot more

* Spend more time programming

* Spend more time programming in python -- I have to master python

* My text manipulation should be a lot better

* More
- meta
- consolidated
- streamlined
- responsive

* Less
- latency

* I have to get a lot more 'meta'
Get things like codelingo into my workflow.
Always write in a 'fuzzy' way.

* I don't know python libraries like the back of my hand
But that's not what it's about. I need to get good at search.

* In all seriousness, I have to be going very deep on Deep Learning
Well, TensorFlow actually.
Because in the future I actually need to be building stuff with it to remain sane.

* My learning environment must be more fluid
It must be recursive or graph-based.
Lots of inceptions.

* I must seek concessions from work
It's important not to be taken advantage of.

* I must not deceive myself

* TODO Improve my code navigation abilities
I need to be able to search a python codebase rapidly by file / module / class / method
Set up ctags again.

* I must get better at racket and haskell. It's kinda important
That is my long-term strategy.

* Keep learning things which I understand
I have to learn for understanding alone.

* Need to be able to far more seamlessly navigate freenode and other chat servers

* Leave cues everywhere in my code for finding things I need

* Need to rely less on my own search functions and more on the search functions of package managers and google
This is kinda important. Can I do this?

* Get faster with python

* I must start shedding dead weight
My python environment is frustratingly fragile.

* I must keep on learning
As hard as I can -- and break down the barriers to learning.

* It's all about the search functions -- and types
Build up search functions.

Later it will become important to have
augmented reality in order to understand
the internet.

There will be too much unrefined
information and generated content.

When lots of content is generated, you
need augmented reality combined with
artificial intelligence.

The AI is required to make sense of
generated content, which is unpersonalised
information.

It's unpersonalised for your senses.

* It might be important to start basing my work on a functional operating such as guix or nixos

Generally, yes. Nix has great support for haskell libraries, AFAIK. Guix uses guile scheme, so that certainly attracts scheme users.

* I should try to be highly entropic with my facebook messages from now on
Frequent and entropic.
But nellie's stuff is good because it is highly relevant and complex. It's taylored.

* It is true that I need to become better at conversation
And what is the way to do that? Ugh. Maybe it's through NLP.
Rhyming and poetry is incredibly skillful and amazing to behold, especially when it's relevant and good.

* The interface needs to be programmatic

* John Kitchin

* I need to mind what I learn

If I learn a random piece of information which is hard to google for
(such as a scene from a random clip). Then it's hard to google for an a
waste of time.

Example:
- Agent smith the tomato scene from matrix reloaded
  I want to rewatch the actor getting frustrated during production

* I need to develop much more powerful tools
They should be based on information retrieval systems that will scale.

* Try to become a wordsmith, but of a different sort to Nellie

* I really should be programming as much as possible
Maybe I should go to the marsh today and do some programming.

I probably need to try to get this job at Pacific Edge.
It will take me where I want to go.

* Speak up and say stupid stuff during the interview -- I'm expected tog
Try to communicate as much as I can.

* I need structure to my programming environment

* I know I can't compete with raw intelligence. I have to use smarter ways of learning

* It's important to get into natural language processing
It's important for the consolidation of information and continual learning.

* I should get in the habit of writing to Nellie every day, even if I don't send to her
Then I'm ensuring a baseline amount of communication as I put myself into the habit of doing it.

Constant communication is probably a good thing. Try not to be too sporadic.

* Try to incorporate as much of my learning into what I do as possible

* I have to be strong
Spend less time wasted. I must focus.

* I want to be making music, writing songs and making stories with Nellie

* It is vital to lean heavily on languages as a way of consolidating knowledge

* I must get better at higher and higher level languages. Ones with momentum
Things like CodeLingo's DSL.

* Move away from downloading data and towards being able to access everything via mosh
Have things on remote servers. Always prefer this.

* Haskell really is a language where you are meant to memorise many function names
And simply write out haskell without much editor support.

* My decision tree stuff must be extremely abstract
How can I keep my decision trees as the most abstract thing?
The place of logic?
The place where I make decisions?

* I must be coding more abstractly
The editor must allow me to do more haskell.
This is the only way forward.

* Try to get good at haskell
It can do anything in theory.
It's definitely the most abstract language I've learned so far.

* Get better at the actual learning and reading of haskell

* Just start writing all over facebook
Document things on facebook. Show off what I can do.

* Do much more in haskell -- master it. Try to master it soon

* I must meet more people who are awesome and be the person who I think is awesome so I meet more awesome people
Have less fear. Anything goes in the future.

* I have to get to the point where programming and learning in a meaningful way is so easy
So easy that anybody who procrastinates, I can know that they do not have a better strategy than me.

* When I go to the camp, make sure I'm looking all cleaned up
Take care of myself. Also, be myself.

* Focus on learning more abstract languages
This way I'll be able to reason about things like Deep Learning in the future.

* I need to seek to be good at what everyone wants to be good at deep down
Try to get good at the things that people don't want to admit are important to them.
Like emacs.

* Haskell is important because it is declarative

* Spend most of my time learning natural language processing

* Learn to love code more and visual stuff less
Or I can love code and learn to love making visual things with it.
I have to learn haskell. It's the future. It really is.

* I need to:
- a. be more confident
- b. work harder on my stuff
- c. be happy

* I'm going to be able to ask out anyone I want

* The more free I am the less regret I will feel

* I'm not distracted, which is good
Remain undistracted. No point in being undistracted if I am unhappy.
Unhappiness is a distraction.

* Just start building things in python
Build, bulid, build.
I need reflection and search in order to master python.

* Try to learn haskell as fast as possible

* Don't forget about building filesystems

* Need to think of something to build for the CS school
Take a lesson on something.

Pick something that will teach them a new way of thinking.

* Definitely start doing the same with racket lang that I am doign with emacs lisp and python
Get into meta programming and also reflection with each of these languages.

* I must be creating functions all the time and re-using code

* Build stuff to help communication

* Start treating communication mediums differently

* In the future anyone will be able to make bots for anything easily
It's hard now, but it will be easy in future, somehow.
Make sure I stay on top of it.
I have to stay on top of deep learning, automation, simulation and search.

* I need to continue working very hard
This is the only thing I know for surse.

* Just work very hard on haskell for a while
It's very much worth getting good at it.

* Get better actual code editing
Get better at emacs.

* Just learn what things are useful for
- tensorflow functions

Stop trying to learn how to *make* everything.
I only need to be able to navigate and manipulate code.
I need a light touch, not a heavy one.
Part the streams.

* Programming with tensorflow or whatever libraries I use must be intuitive

* It doesn't make any sense to me that I can be alone

* Keep trying. Keep moving foward. Keep building. Keep learning
I must reach sustained happiness.

* There are more important things to do than to simply be having fun
I need AI. It's tempting to watch the world burn. It's fun. It's harder to

* Need to get good at
** functional programming
*** currying

* I have to embrace who I am. No time to waste
It's important to continue getting stronger.

* Keep learning the right stuff

* Right now the computer is a good interface to the internet. It won't be enough in the future
The internet is designed to enhance human intelligence.
It's a safe place. Especially facebook.

* TODO Start building my own haskell operating system
Or contribute to an existing one.
I need the emacs of haskell.

* The type of searching I'm doing right now is not good enough. I have to be using tools like Hoogle
Search with Hoogle. Learn how. Get good at it.

* I have to start building a profile on Google somehow
GitHub is good. It's the best place to build a profile.

* TODO Don't get caught up in

* Get much more powerful at computers
Flaunt it on facebook.

* Keep trying to automate ghci
Keep learning haskell. It's the right thing to do.

* All I have to do now is pull in the net

* Start doing more haskell for the purposes of text editing

* I need to stay on top of NLP. Being a master of NLP will unlock everything

* I should really be doing courses, taking notes on those courses, building hyperlinks and things
A course could be a youtube video.
https://www.youtube.com/watch?v=dogYA3s7KQE&t=98s

* Don't even go on facebook
Turn on notifications so I never even have to go to facebook.

* Facebook means nothing compared to actually living

* I need to build up, as much as I can, momentum with either racket or haskell
Momentum means, using libraries, reaching the limits of the abstraction.
It's going to take quite a lot of practice to achieve that in either. I'm barely there with bash.

It is very important. I must work hard and try to be as little distracted as I can.

* When you're in the dumps, little things feel like big things

* When I put myself out there, I always put myself into my own category
There is no other competition. Any kind of competition I imagine out of fear, is simply non-existent.

* I have to be a light that burns both bright and long

* Keep using facebook because of the technology

* My profile picture is not unique in its awesomeness
For example, there is Alana Donkins, which is much like mine except she is a nicer person than me.

* Need to work on my real-world appearance as opposed to my facebook appearance

* Use bots more often. This is important. Emacs is great for integrating bots

* Much of what I do programming-wise is a waste of time because it's not abstract enough
It's important to start reasoning at a more abstract level.

* Plan
Try to get into any AI company.
DialogFlow is probably a good option.
Soon the software to do my own programming will cost too much.
That is, unless, I continue abstracting.

* It's important to start scripting IRC and making bots

* I must move deeply into racket and haskell
Moving to emacs first was a good move.

It will be hard to proceed into racket and haskell. They are both
difficult languages to become advanced in, due to lack of decent
tooling.

* Become a Year 2020 developer!
** Rely more on chatbots for documentation (as opposed to setting up lots of software)
*** Automate chatbots through emacs
*** Use emacs to practice my NLP

* I have re-enabled semantic-mode across emacs

* I have to make C++ work with emacs
...or do I? :P

* I'm currently not excited by programming, which is bad
I need to get back to excitement.

I do everything the hard way...

* I need to learn to build things with scaffolding
google queries as placeholders.

* I need to learn more abstract programming, so I can start writing haskell code instead of rolling around in the mud

* I really want an environment that allows me to edit a wide variety of formats with only one or fewer formats
- ini -> yaml
- yaml -> json

* The problem with racket and haskell are editors

* Do more BigQuery

* I need to, rapidly, loosen up

* I must be generating code in order for emacs to make sense

* Keep getting good at whatever emacs is best at
That's haskell. That's my future. Because I'm stubborn.

* I need to be making snippets
If I don't have emacs plugins for abitrary SQL variants, put all the snippets under SQL with prefixes

* I need to learn racket properly

* Need to be able to better manage IRC
irssi is not powerful enough because I want to be able to use IRC bots like REPLs.

* I don't even know how relationships work these days
But that means a lot of things don't actually matter, which I think do matter.
Play to my strengths instead of focusing on my weaknesses. That way things will naturally come together.

* Being able to parse stuff with duckling and semantic would be so awesome
Work towards it.

* The reason to use the safest langauge is that it's easiest to generate code in other language

* Get good at the basics
- haskell
  - Start writing my own functions
    Automate as much as possible.

#+BEGIN_SRC sh
  ifl haskell code generation
#+END_SRC

* I have to
- be more confident
- fear is debilitating and will only make things worse
- confidence is almost like truth
- face my fears

* Rebuilding will be hard
** Ensure that I continue building up my things
Integration of knowledge is very important.
I need to gear my environment towards text.
Therefore I need to learn -- continue with this:
- haskell
- github/semantic
- facebook/duckling
- tensorflow
- probability
  - problog
** Learning JavaScript is a waste of time
** I must be less fearful
** I must be myself -- be as much myself as I can until the end of the year. This is important
I can only win if I am myself.
** Since it's going to be the last
** I must try to be more humble

** Build a chatbot
bit.ly/2L0kmYZ

Applying my NLP knowledge is important to get jobs.
Turn what I know into buliding chatbots. It's an outlet for what I'm learning.

* Learning Haskell is going to be worthwhile because it's full of rules
I'm learning a system of controlling abstraction.

* I definitely need to get better at the duckling parser
Full speed ahead with haskell.
Make PRs to this thing. It's totally worth doing this.
I could even focus on the Rasa fork.

* macros instead of snippets
I must work towards this.

$MYGIT/mullikine/mullikine.github.io/practical-macros-in-racket-and-how-to-work-with-them.org

Then I should work towards building my own
language.

#+BEGIN_SRC racket
  #| Make macros instead of snippets |#
  #| $HOME/notes2018/ws/racket/examples/racket-macros.rkt |#
  #| $HOME/.racketrc |#
#+END_SRC

* Yes, make lots of decision trees with emacs
BUT, I need to be making trees based on super high-level code generators.
** TODO I have to learn:
*** Parsers
- semantic
- duckling
*** Generators

* Purcell is good at haskell
I should try to get as good at haskell as him.

* Need more focus
** TODO Build a haskell compiler in haskell
http://dev.stephendiehl.com/fun/001_basics.html

* Always consider my environment to be evolvings

* I should be using my computer to recall information, rather than trying to remember everything I learn
** TODO Search the pages I have visited for stuff

* Have more confidence in what I have written down
It's part of the knowledge I have acquired.
I shouldn't expect to remember everything by heart.

* I think I have enough general knowledge of haskell to start trying to actually program with it
It's important to be able to do that. Breaking down barriers to actually using a language is very important.

If I get into haskell, I should work on something like Rasa's fork of Facebook's Duckling.

#+BEGIN_SRC sh
  diff <(cd $MYGIT/RasaHQ/duckling; git log) <(cd $MYGIT/facebook/duckling; git log) | vs
  vd <(cd $MYGIT/RasaHQ/duckling; git log) <(cd $MYGIT/facebook/duckling; git log)
#+END_SRC

* Being able to edit code is enough for an editor when you can follow tutorials that use high-level APIs

* It's far more important to develop search functions than to learn someone else's programming environment

* Need to make my work easier.
Do this by
- abstracting my work out into a natural language I am building for myself
- automating this with my own DSLs
- relying more on search
- formulating search queries
- generating search queries
  - generating natural language
  - generating api queries
  - generating regex

* It might be more important to learn spacy better and somehow integrate with irc via racket

* I should be recording my entire terminal so I can always search for questions I may have asked
It's simply inefficient to not do this.

* Do more reading and implementation
And try to sustain it
This is more important than building exactly from the ground up.
Find the place where change is less frequent.
Ground-up learning when it comes to programming languages can be a place of high volatility.
E.g. Python.

* In order to really learn advanced concepts, I must build on something
Therefore, I should learn basic racket before trying to remember advanced stuff.
I need to be able to make useful things in racket and haskell.

* Just make more links to things
I don't *need* to explicitly write out the definitions of things.
But I should make a mental map of things.

* [#A] Study TensorFlow -- just study it
https://stackoverflow.com/questions/49968105/keras-eager-execution

I do want to become an expert in it.

* Perhaps I should try to simply be good at a language that doesn't need codelingo, for instance

* Keep trying to improve my emacs and racket. This is important

* Just keep learning about when tensorflow functions are used

* Keep org mode simple. Keep the bindings nice and fast

* It's important to learn the tools of the trade. I must understand TensorFlow inside and out

* TODO Simply read arxiv a lot and use NLP stuff to help me do that -- this is a very good idea
Get better at reading arxiv.

Read as many summaries as I can.
I must stay on top of the information.

Automate the process of getting a reading list of TOP arxiv papers.
Then just read their summaries.

* Learn to practically do tensorflow

* I really don't care about things like fine art. There are enough people who are distracted

* There is much to know about problog, haskell and racket
And it IS relevant knowledge, regardless if I am paid for it. I've chosen higher reward languages to learn.

* I need search functions -- that use DL if necessary

* Must be using lists of things in this way
** Search for them
$HOME/notes/ws/lists/snippets/haskell.txt

* TODO get further into DSLs and Deep Learning
It's important to learn DSLs over libraries.
DSLs help with understanding.

* Maybe I should only aim to be able to read haskell
Nah, I should try to make things in haskell.

* Use emacs and my terminal environment to help me to learn

* TODO Figure out how to scrape all anchors (including URL) from emacs eww
I'd need an org parser, firstly.
It has to be easy or it's not worth doing.

#+BEGIN_SRC text
  * Tossing coins
  * Bayesian networks

   * Using probabilistic facts
   * Using annotated disjunctions
   * Using first-order
   * Using multi-valued annotated disjunctions

  * Rolling dice
  * Probabilistic graphs
  * Social networks (Friends & Smokers)
  * More features
  * Semantics of Rules with Probabilities

   * Intensional probabilistic facts
   * The 2008 semantics and conversions

  * Higher-order functions / Meta-predicates
  * Inhibition effects

   * Example 1: Short Intro
   * Example 2: Social Network
   * Example 3: Intercausal Cancellation Model and Medical Domain

  Parameter learning

  * Bayesian networks
  * Social networks (Friends & Smokers)
  * Naive Bayes

   * Independent and Identically Distributed examples (iid)
   * Features with Unused Terms
   * Documents in a Network (non-iid)

  * Noisy-or
  * Structure Learning

  Sampling

  * Inferring an Arithmetic Expression

  MPE Inference

  * Bayesian network

  Decision-Theoretic ProbLog

  * Umbrella
  * Viral Marketing

  Examples from tutorial slides

  * Very basic examples
  * More examples
  * Stochastic memoization
  * Bayesian learning
  * Complexity of querying
  * Smart students

  Various examples

  * Monty Hall puzzle
  * BousiProlog
  * Crowd protocol
  * Examples from PLP 2015
  * Nested Number Guessing
  * Hidden Markov Models
  * Probabilistic Context Free Grammars
  * Stochastic Logic Programs
  * Probabilistic-Programming Datalog
  * Bayesian Dataflow
  * Aircraft Flap Controller
  * Estimating Causal Power
  * PRISM
  * Semantic Web
  * Ping Pong
  * Incomplete Information
  * Do-Calculus
  * Bounds for a Query with Infinite Support
  * Alternative view: CP-logic
  * Taxonomy

  Advanced concepts

  * ProbLog as a Python library
  * Database/CSV knowledge base
  * Algebraic ProbLog (semirings)
  * Using the Prolog engine
  * Urn-ball Model with Poisson Prior
#+END_SRC

* I must destroy all my fear
People do want to talk to me. All the YAs. I can talk to them all. Just be myself, and be my strong self.
I should always reply along the lines of, oh, you love maths? That makes you one of the most awesome people I know.

* I must concentrate on learning DSL. This is extremely important
I must finish this training I am giving myself. I'm so close and I'm unlocking my mind.
Keep going. I'm learning so much.

* It's my responsibility to continue studying probability and deep learning

* It's very important that I keep updating my perspective on what it means to be the computer scientist that I am

* I should keep improving search functions and learning stuff that I doubt I will be able to master
The search functions will be there in the future to help me to remember things.

* I must become very good at python -- and I can
Deep learning is the trump card though.

* Try not to be incongruent
Congruency is when what you're saying and how you're saying it match.

* I should record everything on my terminal?

* Don't need dictionary search
All I need is a text file and regex.

* TODO [#A] I must take my programming to a new level
I MUST take it into racket immediately. I'm delaying.
This is actually vital.

* Ultimately, its true that I need to be wrangling abstracts and recipes with natural language
I need to be able to organise my knowledge.

* Yes, start recording the URLs I read

* Part of the problem with a pipeline such as this is that if latter parts of the pipe break then the earlier tv1 script doesnt work
#+BEGIN_SRC sh
  # arxiv-summary "https://arxiv.org/abs/1906.04493" | tv1 | sed -n '1' | v
#+END_SRC

* I need to be able to indicate things to myself through programming
Have a language environment that I know well and can integrate my knowledge.
The more abstract I make it the better for me.
Master dictionaries.

* Start lurking on channels that specialise on stuff like tensorflow
If I lurk on TensorFlow, then that is plain awesome. It's not obscure enough to be weird.

* I need to nerd out in a way where I am building real stuff

* Start cutting down on the amount of work I do
Learn more long-term things.

* Keep building search functions
Also, parsers, user interfaces and deep learning tools.

* Stay happy and focused. That's the most important thing. My strength is my actual strength

* I have basically no time for facebook
I have basically no time for facebook.

* Get into parsers
Parse markdown files and generate snippets.

* I MUST do more code generation
The more abstract I get the easier things will get.

* Master things where I currently have the advantage
Move quickly.

* Stop making decision trees. Make more search functions and DSLs
Learn more racket and haskell.
Although powerful, deep learning is the symptom of the problem, which is that I am a noob programmer.

* Keep getting better at racket

* I really need to see the bigger picture and write code that I think will be important for building the future
It has to be robust code. The code I write can't be python. The fate of the world isn't on python.

* It's important to have one language to tie all other DSLs together
One language to rule them all. Seriously.

* I must get very good at racket. This is important -- to be good at the language.
It's more advanced than many other languages.

* Stop wasting time with languages that have bad documentation?
No, the solution is to get better at obtaining arbitrary documentation.
Remember my googling functions.

* It really is important to learn the abstract stuff in haskell
The problem with racket is complexity and learning details which don't matter.
The ends must justify the means.
Racket is a good language for manipulating text and making DSLs quickly, but you're not building on pure, solid foundation.
Write less emacs lisp.
Racket is a language I use to better myself.
Haskell is a language I use to empower others.

* Do not learn any single language. Learn languages instead
I do realise it would be very powerful to learn a language such as Go to expert level.
I do not doubt that.
I can see that I would be a much better developer if I could do that.

* Once I learn racket will I'll be able to generate anything

* Compiled languages are important for me to learn
But the substrate of which I program will change.
One day using English language will be very primitive.
My terminal will become very primitive soon.

* It is actually far more important to learn languages like racket than the mainstream ones such as go
https://docs.racket-lang.org/ts-guide/types.html#%28part._.Polymorphism%29

* I will need to learn a lot of languages to manipulate the text that I see
Text understanding, manipulation and display are the most important things to be studying.

* I must be able to program without inhibition

* Keep learning DSLs
They are very important.

I have momentum. Maintain it.

* Accumulate more programming languages
- python -- learn it well

* PCRE lookaround
| q(?!u) | u does not follow q  |
| q(?=u) | u follows q          |
| (?!a)b | a does not precede b |
| (?=a)b | a precedes b         |

** [#A] Place help where I need it
#+BEGIN_SRC sh
  vim +/"# \* PCRE lookaround" "$HOME/scripts/scrape"
#+END_SRC

It would be better if all the languages I used, I provided help for the functions that I use.

* Spend more time memorising PCRE syntax -- I must know it all -- it's important

** TODO I must have a generalised snippet manager -- based on google search?

* Spend more time learning programming languages

* It's important to become good at probabilistic parsers because the text underneath will keep changing

* Keep getting better at programming
It's basically my ace in the hole.

* It's important to latch onto abstract programming languages as soon as possible
Haskell and deep learning are very important for having something to make for others.
Racket is important for being able to make something for myself.

* Keep solving programming problems

* I must start actually making functions in haskell
Make a 'b' function for haskell.
Learn to wrangle with strings.
Learn megaparsack

* Although this deep learning stuff is important, if I simply master a language
- such as racket
I'll be very enlightened and confident.

* I have quality. There are good things about being my age
I existed in a good time.
The 90s. Varsity Lakes.
Listen to wonder boy. It'll reinvigorate me.

* I have to learn very effectively to become a good programmer

* From the most basic up to the most complicated, I should learn what the functions do
$MYGIT/rasbt/deeplearning-models/tensorflow1_ipynb/mlp/mlp-basic.py

Then I'll be able to read tensorflow model code.

* I really need to be running racket from emacs instead of bash
It's hard to make bash one-liners if it requires complex logic.

* Make lists of functions I have learned
- tensorflow
  $HOME/notes/ws/lists/functions/tensorflow.txt

Make a function for adding to this list.

M-4 -- add sexp/symbol at point to list

Make an fzf for searching the lists directory for files.
And something to add the symbol at point to the file.
Need to be able to add to named lists from emacs.
Also fuzzy search the lists.

* Move out of bash and simply start using the language of choice

* I'm highly coupled to my development environment

* I want to learn haskell because of the way it will help me to think
And I want to think in that way.

* I have to build things with the languages I know
Learn them properly and then build things with them!

* Do not claim to be an expert on particular topics unless I am
Say I'm familiar with a lot of different topics.

* I guess that having knowledge of tensorflow and probability
Is vital for my CV.
I must understand the process.

Try to understand the math and the processes.
I don't need to become an expert in the actual libraries, which are bound to change.

* My job is to learn
I have to be able to conceptualise thing in an elegant way, not get
stuck in the mud of information.

* Become more 'alive'. Master my haskell programming
Then master deep learning.
Try to share it all with someone.

* Try not to add more complexity to my tmux environment
Instead, move into haskell.

* It's more important to learn haskell right now than to extend emacs

* It's important to learn haskell to completion of understanding
I need the abstraction.
Also, I should get very, very good at it, for job hunting purposes.

* Need to start actually building things with Haskell

* Keep learning haskell
I want to be able to do deep learning with haskell.

Haskell has to be the language I use to prototype data structures, or anything that is recursive.

* I guess there is no avoiding it. I must learn haskell functions from the ground up
Relearning programming.

* With haskell, you can't just import everything
Well you can, but you need to supply the full path of the things you wish to import.

* Need to become actually good at haskell, not just able to use it
When I get that good at it, I'll be safest against AI.

* Keep moving into emacs
No more bash snippets.

* I must abstract my environment away using haskell and deep learning

* Need to do particular things more carefully
When learning languages I should do them more carefully.

* Make my emacs more and more complex
For example, my H binding in selected.el.
Complexity is fine if I can remember it.
My entire environment should stop updating and simply become more complex.
Rely on google more.

* Build up programmatically
Generate code.
Get out of the muck.

* Integrate stackexchange into my coding
They way I code should be initially a mixture of google searches, stackexchange searches.
As I blueprint.

* Need to be able to more easily convert code formats
How can I search for things to convert format.

* I must master python with emacs

* Build up
- google search capability
- basic deep learning capability
  text classification and generation
- text editing (with racket)
  It's really all about language creation.
  Learn how to parse.

* It should be possible to edit remotes visually, with a text editor, rather than entering commands one by one
#+BEGIN_SRC text
  3fb3faf2 master ~ mullikine/master 18:18 tutorials/text » my-add-git-remotes
  fatal: remote mullikine already exists.
  3fb3faf2 master ~ mullikine/master 18:19 tutorials/text » git remotes
  mullikine       git@github.com:mullikine/docs.git (fetch)
  mullikine       git@github.com:mullikine/docs.git (push)
  origin  https://github.com/tensorflow/docs (fetch)
  origin  https://github.com/tensorflow/docs (push)
#+END_SRC

* Make notes in my glossary like this
It's a way of learning faster.

#+BEGIN_SRC text
  softmax
      ewwlinks +/"This stack of RBMs might end with a a Softmax layer to create a classifier, or it may simply help cluster" "https://skymind.ai/wiki/deep-belief-network"
#+END_SRC

* Make some ultra-terse bindings for searching for code using selected.el

* Use colab more
Use emacs less.

* Try not to be constrained by things
Use whatever documentation system is working for me.

* Return to TensorFlow
I don't have an option really.
I don't have a powerful enough computer to do anything except for learn.

* Try to stay within the language rather than branching out
- racket

* Persevere with racket and haskell
I must see them through to the end.

* I have to make it past the learning stage and be working all-out on haskell and racket

* I must aim towards deep learning, but consolidate with haskell
Build my environment up to be able to do anything.

Learning is the most important thing to be doing.

I have to become good at haskell so I can consolidate my learning into
it.

* Just start blogging on facebook about what I'm doing
Use facebook for what it's good for.

* Every racket part of syntax should have an example
I must automate the process of finding examples.

** TODO Make a command to
- show documentation for a racket function
- show an example for a racket function
  Search a codebase for it.
  Use 'ead' because that's easy.

* Start memorising functions
Master org-brain.
Just start using it.
I need more than 1 graph.
Is this ability to manage more than one graph not already present?

* The racket documentation is now a playground for me
Because it works in eww.
How can I integrate more learning into emacs?

* I must master racket so I can automate my computer
Break down all the barriers for working with racket.

* Lets try to get actually good at racket and haskell
I must be learning actual functions or it's a big waste of time.

* It's more efficient to focus on learning one language at a time

* Read fewer things. Read more carefully. Read tougher things.
Integrate. Build up.

* There's nothing wrong with using shanepy

There's nothing wrong with using lots of different languages.
It's a strength, not a weakness.

* Write my scripts in the nicest language for the task
$HOME/scripts/play-spacy-en

Bash happens to be amazing at writing scripts, which is perfect for the task.
I want to be constructing something monolithic in a mainstream language, though.

* I should generate github queries

* I should generate ALL the queries I make to places

Generate the code and feel comfortable in one language.

* For things like seml, I should
https://github.com/conao3/seml-mode.el

* Just use haskell
I mean there is no problem with learning it.

* Tramp is actually very nice

* Many things are muscle memory now but I don't want to rely on muscle memory
Rather, I want to think my way out of situations.

* My racket will build up and up to the point where discoverability becomes very important
** Same with haskell

* It's probably quite important to learn how to use haskell so I know how to work on such projects
There are probably very easy examples that I will be able to see it the
future.
In the future it will be easier to learn haskell.

* Somehow I have to try to continue learning even when things get hard

* Sophie's paper was published on sciencedirect
This is also where I read about "Cinnamic acid" inhibiting "tyrosinase".

#+BEGIN_SRC sh
  vim +/"http:\/\/goo.gl\/qQaFpw" "$HOME/notes2018/biochemistry.txt"
  vim +/"https:\/\/www.sciencedirect.com\/science\/article\/pii\/S0012821X19302328" "$HOME/notes2018/glossary.txt"
#+END_SRC

* See Sarah as she is. She's far more mature than I was
And in many ways she is far more mature.

Don't be worried about coming off as too mature.

I'm also more mature that I think I am.
I'm ready for a very tough job.

* My blog should actually use org-brain

* Racket is the new emacs

* Learn all of the most abstract formal languages
Do this so I don't have to learn as much other stuff.

* I should be creating my own language
My own words.
Or not? Not yet.
Natural language is more useful as the language of talking to other humans.
It's still a good idea to learn about how to query the world of natural
language; to become better at querying.
I should be creating my own programming languages, and be making them as
expressive as possible.
I must be able to 'entail' other programming languages with my own.
Really, the entailment should be me trying to entail what I want.
How can I entail what I want?
I could upkeep my own natural language model for myself.

* Learn haskell syntax
The ability to search for functions and code will come.
Semantic search will come.

* Don't become a slave in the gig-economy
https://www.vox.com/policy-and-politics/2019/5/30/18642535/california-ab5-misclassify-employees-contractors

* Build up knowledge in certain areas
- org-brain

* My current means of programming is not enough
I have to switch to deep learning.
I have to be building my own languages no matter what other people tell me.

* I need to be building an operating system in racket

* When it comes to listening to people who ramble or have uninteresting conversation
** Consider this
You're not engaged in conversation, perhaps because you have difficulty
relating to the content or because the topics are not relevant to you
(in which case you should ask pertinent questions to find a way to
relate or find relevance). You could also have Attention Deficit
Disorder, where you lack the ability to focus - this can be treated with
Mindfulness training or, in severe cases, with Ritalin.

Or you might simply be bored and craving more creative/interesting
input.

There have been studies that suggest that younger people have problems
focusing for on longer texts and have become 'skimmers' - sifting
through text for nuggets of information and thereby skipping over
nuances. You could have that in verbal communication, where the
conversations turns into a drone with the occasional emotive word that
catches your attention to the detraction of the rest of the
conversation.

** Possible mitigation
Ask pertinent questions to find a way to relate or find relevance.

What kinds of things do I want to know about other people?

The real challenge is working out how to make what they are talking
about relevant to what I want to know. That's the challenge.

* Use org-brain more to remember things that I am trying to learn
The glossary is also important. Remember I can link to everything using commands.

* Improve my code search functions
Keep improving them.
For thingts like searching for code snippets.
Download github repositories that contain code snippets.

* I should use racket to generate snippets
Seriously.
Get better at racket.
Then I can generate python, generate queries.
I can build my 'lisp machine'.

* Once I have mastered racket I should use it to generate as much code as I can
Truly master the art of creating DSLs.
Once I have done that I must use my racket and emacs knowledge to learn Deep Learning.

* Improvement plan
- Get faster at emacs
- Get better at racket

These are the only 2 things I need to do at the moment.
There is really no need to go for haskell yet.

** After I have done that I must start making DSLs
- take advantage of language models
- generate code from other languages

* Once I've mastered racket's DSL-making syntax, I will have mastered code generation for many, many DSLs
#+BEGIN_SRC sh
  ewwlinks +/"#lang jsonic" "https://beautifulracket.com/appendix/why-lop-why-racket.html#where-languages-excel-as-interfaces"
#+END_SRC

I should actually start making DSLs like jsonic for other DSLs.
For the purposes of being able to generate other lanugages.

* I CAN and WILL be creating my own languages
I will do it easily.
Keep going.
I'll build languages for the environment.

But I must be careful. Remain abstract and remain ambitious.

* It's probably possible to master emacs' text properties.
It would be awesome to be developing my own web browsers and things inside of emacs.

* Keep getting better at emacs
Keep integrating with racket and haskell.
It is worth it.
Keep integrating.

* Maintain a strong foundation in information theory

* racket is much better that haskell at metaprogramming
https://www.quora.com/What-are-the-relative-strengths-and-weaknesses-of-Racket-and-Haskell

No non-Lisp language could ever hope to even stand in the shadow of how
simple and powerful meta programming and extending your language is in a
Lisp like Racket.

* Aim to be good at ALL programming languages
This means I need to automate code search and learning about syntax of
programming languages.

As a side-effect it's actually the only way to get good better at
learning tough languages, such as racket.  And learning a touch language
such as racket makes me more competent all-round.

** Becoming great at the most abstract languages will allow me to become good at all languages
Everyone is going to become good at all languages so it's imperative to
get to that stage by learning how to do it myself (i.e. by learning more
abstract languages).

I have to be able to build my own tools instead of use other people's
tools in the future.

* Start by learning how to actually make things in racket
The tricky syntax transformers can come later -- and they WILL happen.

* I must get much faster at emacs
My terminal environment is a little slow.
Finding and filtering stuff should happen inside of emacs.

* [#A] TODO I need to be able to search the youtube subtitles that I have read / listened to
I can achieve this by building a racket ecosystem for myself.

* What I'm doing is unsustainable
The amount of learning.

I have to focus and reduce time spent.

* Just get better at spaCy and racket :)

* All my code should have nice documentation and be easily accessible
Racket :)

* The real prize is getting better at using a computer

* Ask myself what is the thing I need to get better at
It might be haskell becasue it will help me to think more abstractly.

* NLP for Google Search is what I have to do
I have to master the English language.

* Need to learn languages for manipulating languages

* TODO I should be able to:
For each match of readsubs "http.*" in .zsh_history run org-clink on the url.

This is worth learning how to do.

* I have to become good at reading and absorbing knowledge from code
It's probably less improtant to be able to make my own stuff then be
able to read stuff, although building my own stuff is a direct
sideffect.

See it in that perspective. Try to understand what is going on.

* Skim through how to use spaCy

* Focus on NLP, not other topics

* Use NLP libraries to help me to learn

* Try to learn faster

* Stick to English, mostly.

* It's still worth reading about older NLP algorithms because I can learn how to search for concepts

* Computers in the future will be running a lot of artificial intelligence
But the beauty is, the AI will run on top of everything I currently do.

Plain text will translate faster than anything else.
The terminal is immortal.

* Need to find my momentum before marrying Sarah?
Sarah would help me to make it anyway.
But it's still the right thing to do to get to unstoppable momentum first.

haskell and racket are the only way

Scarily, maybe building an editor in haskell and racket is the only way.
I'm not sure about that.
I think it's not possible to make it myself.

* I think there will come a time where our best friends will become chatbots
This is because people have a need to learn which surpasses the need to
have such low entropy conversation.
Evidence:
- People listen to youtube channels more than other people.

* It's fairly important to remain good socially as I upskill
Being able to be social is a real skill.
Currently I have it, like I have my health.

Fuck that social bullshit. Just be myself.
Think of the things that won't let me down, such as aweshell.
https://github.com/manateelazycat/aweshell

There's no time.
https://github.com/riscy/shx-for-emacs

* It's actually fairly likely that I can't have a partner because I'm too smart
[[http://docs.racket-lang.org/reference/port-lib.html#(def._((lib._racket%2Fport..rkt)._port-~3elines))][docs.racket-lang.org/reference/port-lib.html#(def._((lib._racket%2Fport..rkt)._port-~3elines))]]

* The code I struggle with must be abstract
The struggle == the learning. Make it count.

* It's important to be staring at racket code that I don't recognise and trying to understand it
I have to be able to read it like reading English.

* The number one rule is that I must not be awkward?
Confidence is good because it probably means I have a plan?

* Write down a lot of difficult information
I must be looking at future knonwledge as often as possible.

* Focus on actually learning racket syntax
To do that I must be more organised.
Because the tools will catch up.

* The more DSLs I learn, (including haskell and racket), the more I can hold onto things
Simply learning Deep Learning will not have the same effect.
DSLs are the only way to consolidate and remember things.

* The hard work is actually learning
It's what I have to do as a job -- learn faster, learn more smartly.

** [#A] It's more important to learn than integrate. Sad reality.
I have to be training my mind to do perpetual learning.

And, somehow, I should stay afloat. It's kinda like flying on jupiter.
My solid foundation needs to be my technology, not the earth.

* My editor must be ready for language-agnostic editing
Because the future is a code editor built on blockchain and AI.

* I have to abstract quickly
Need to get into haskell and racket in a better way, and continue learning about deep learning.
Haskell and racket are conceptual learning tools.
Math is purely functional.

#+BEGIN_SRC sh
  vimlinks +/"Mathematics is a purely functional language. " "http://matt.might.net/articles/discrete-math-and-code/"
#+END_SRC

Get out of the scripts I am writing and write high level code immediately.

* I should start actually just remembering racket functions
This is important, actually. I have remembered a lot of my own
functions. I should be learning functions that everyone knows, so I can
benefit in the future. They gather interest.

* consolidate and focus
I have to start consolidating my knowledge and focusing my effort onto
specific things I want to become PRODUCTIVE at.

- haskell
- deep learning
- racket

* My sp script is unmanageable. With lisp I would be fine
$HOME/scripts/sp

* TODO I need to switch to racket for shell scripts
Make it a priority.

In all honesty, maybe I should be focusing on learning the things I need
to learn and that is all, without worrying.

My brain is a perfectly working computer.

* Learn haskell before learning category theory properly

* The tools to harness NLP will make themselves apparent
Editors will appear. Even terminal ones.
Therefore, learn the languages, and learn the topics.
Learn the language of NLP. This is enough.

* Learning new words is more important than learning a new language

* There is not much point in having the chinese syntax highlighting
I need to start capitalising on my knowledge, not regressing.

* Racket will be able to embrace the multi-dimensional AST

* I must move into AI and research
I must do it. I need emacs to help me to consolidate it all.

* Simply read the type signatures and descriptions of haskell functions
This will help me to learn.

#+BEGIN_SRC text
  simpleHttp :: MonadIO m => String -> m ByteString
  http-conduit Network.HTTP.Conduit
  Download the specified URL, following any redirects, and return the
  response body.
#+END_SRC

* The benefit of building your own environment in emacs
- you get to break rules designed for other people

* When I get amazing at racket
- I will be writing powerful code very quickly

Unfortunately there is no way to know what the most important racket functions are.
What are the functions most commonly used?
Can I make something to tell me what they are?
I mean, I should be able to do that.
Rank the most common functions for a project.

The more racket functions I memorise, the more powerful a programmer I will become.
I should try to learn 10 a day.

* I really need to get past the difficulties of learning haskell and racket
Need to be programming at a higher level.

** TODO Perhaps I should learn racket syntax transformers. Then start rewriting different projects
Modify their code using syntax transformers.
This is probably the shortest path to what I wanted to achieve.

* It's more important to build up my racket skills than haskell
I want to be able to search.

* Read more. Take fewer notes

* I need to be able to speak the languages of
- reinforcement learning
- natural language processing (traaditional and deep learning)

* I should use racket to learn haskell
Use racket to generate haskell.
Racket is like snippets and an editor.

* The most important thing to be doing is learning about NLP deep learning
Then I can relax. As long as I'm learning the most important thing, it's fine.

Consolidation of knowledge in the future will be hard.

* I like traditional computer science
Therefore, I should master a language that can do these things.
Racket, and perhaps haskell.

* Do more reading
Make links to the things.

* Maintain my emacs environment
Though I should be harnessing much more powerful languages, such as
racket and haskell within the environment.

I must use my current environment to learn these languages.
Do not upgrade.

* spaCy will be much more complicated in the future <- that isn't a productive comment
https://spacy.io/usage/linguistic-features#retokenization

The only ways to reduce complication are:
- Learn deep learning on search and on languages
  Deep learning on natural language is the only way.
  Because natural language will be used for search and generation.
  Also, deep learning for formal languages.

* Natural Language Processing
https://learn-anything.xyz/natural-language-processing

http://frnsys.com/ai_notes/machine_learning/natural_language_processing.html

* It's important to be using NLP right now
I must learn the fundamentals, at all cost.

* I should spend much more time doing racket
I think it's more important than haskell.
Try to offload into racket.

Just start building stuff.

* I should try to simply get better at searching for libraries and modules
Maybe all this involves is learning racket.

* I should start by learning racket functions that are forgiving and then move on up to stronger type systems

* Make lots of lists of things
And generate code. Fight back against AI.

* Simply read the racket documentation
If I do this I will become an insanely good programmer.

Learning racket is so fast via the 'eww' browser.
I should optimise my racket learning skills before starting a blog.

* Try to commit as many racket functions to memory as I can

* My objective with haskell should be to learn the type system

* I believe it's still important to learn haskell and racket
I want to learn the ability to create my own languages, plus understand
pure functional programming.

After that I want to be able to use deep learning.

* It would actually be quite powerful if I could command external processes from emacs

* Unfortunately, emacs doesn't wait until an ansi-term is done to continue
It's asynchronous.
Therefore, I'd need to have some sentinels and hooks.

* I do actually just need to learn

* When I want something, write the code with sexps for what I want
Then ask questions on how to implement the the syntax transformers.

** Later I can try to prototype entirely new languages
Then ask questions on how to implement the language.

* Do not learn purescript until I have learned haskell
Learn haskell. Stay on track.
Haskell kinda sucks :P because it's not a lisp.
It's still worth learning haskell, even if I will have trouble using it.

* I have to start applying deep learning or I will be left behind
My terminal environment simply will not cut it.

* It's important to get into deep learning for NLP
I should move away from code search and into NLP and deep learning.
It's time.
Select some important NLP things that I will need.
I think I simply need to be building the 'kernel' of my NLP stuff.

* I should definitely just ask someone out that I like
I can do it.

* I have to get away from emacs and enter the world of haskell parsers

* Spend 0 time on facebook
Just study.
Don't learn via YouTube. Stick to text.

* I should get good at this
$MYGIT/albahnsen/PracticalMachineLearningClass/exercises/E17-SentimentPrediction.py

numpy and pandas are like learning very high level languages.
It will teach me a new paradigm of programming, cutting edge NLP.
I just have to keep learning.

It's so easy to read code.
All I have to do is find a place that is dark, quiet and comfortable.

* Remain focused.
Just learn via emacs. It's easy and fun.
There's no real need to watch movies or anything.
This is super fun.
I have to develop an appetite/hunger for it.
The appetite is the thing that makes me a professional.
It's the thing that gives me the edge over the AIs.

* Continue to learn via emacs
https://scikit-learn.org/stable/modules/cross_validation.html

It's very important to build NLP and IR tools to help me to learn.
NLP parsers will be important too.

* The most important thing is to continue building learning tools
Continue developing my environment.
Enter into NLP.
Use APIs.
Move into the racket ecosystem.
Move into the haskell or purescript ecosystem.

* I should not be so stupid to assume that there are not other people like myself, silently working towards an unspoken vision of the future
Therefore, in order to do better than those people I must also maintain my health.

* Until I have a better way to represent and access information
I should just save everything into a big glossary file.

* I should continue try to learn more
Learning is the most important thing.
Don't give anyone else the time of day if they try to take away my learning time.

* Remember
Learning chemistry is like learning deep learning because you remember how things affect eachother.

reduce variance
increase stability
    These happen together.

* corelations
I need to be able to remember how things effect eachother.

$HOME/notes2018/correlations.txt

Write down correlations so I can remember the effect of things.

* I can one-shot learn things if I am familiar with it already
Learning is much harder for topics I am not familiar with.

* Only ever do my learning through the terminal
This is because I can maintain glossaries.
I wont remember anything unless it goes into the terminal.

* Keep perservering with racket -- and integrate it with emacs
It's such an easy language to manipulate.
It will make me a way better programmer.

* I need to solve problems before I even start the job
So I can solve their problems quickly and also anticipate/work on future
problems immediately, whether it's at the same company or the next
thing.

* In order to not be surpassed by AI I must learn things that are of high information entropy
Real information but not of low entropy.

* My development environment should be an NLP playground
** TODO Ensure it is.
Create a lot of text .

* If my glossary seems intractable then I have to build tools to make it tractable

* Before doing purescript / haskell, do racket
I want to be able to generate code.

* I need to take my emacs into the world of functional programming
This is important for my own safety.

* I need to keep on learning syntax to different programming languages
It's simply nice to read and is good for me.
It helps me to understand.

* I cannot be tired. I need a baseline learning rate

** Complain if
- my baseline learning rate is compromised
- my sleep is compromised
- my maximum output limit is surpassed

* Focus on getting more abstract
Only learn things that increase the abstraction in a solid way.
That's actually really important.

* I should
The matrix @1hr6min is an interesting scene. The fun I have should be in
a unified resolve with a bunch of friends; (yes we all agree that the
world is fucked, but we are doing something about it together), now lets
go out and have fun in our own way

* The beauty of emacs is the integration
Dired is probably in many ways better than ranger.

* The programming languages I am using should do a lot of the work of parsing automatically
I should only need to open a file and be presented with the file type and AST.

* My own scripts should only be for connecting powerful languages together
I should connect languages to discover powerful pre-existing tools.

* Without an ensemble of parsers, it's going to become difficult to stand out in the age of deep learning

* I have to leave all these scripts and enter the world of real parsers

* I can't do deep learning on everything
But I can do it on text.

* Do not upgrade from my current operating system. Ever.
Try to bring everything back to it.

* I must find myself a good job and then move on to focusing (narrowing) my energy expenditure
To a language.
A language that can contain the abstraction of deep learning.
Haskell.
Haskell for deep learning.

* It is worth getting better at emacs

* Keep recording function arguments -- use emacs type system to remember functions
I need to be able to search for function names and also use type declarative search to enable me to remember lots of things.

* Do more lisp and less of everything else

* If I had a relationship then what would I give up
I would have to give up certain things and focus my programming on the things I need to do most.

* I have to try to maintain perspective by branching out into the wider programming landscape more.
Have a good general practical knowledge.
Be able to make many things.
Actually, all I need is to become good at 'generating' and 'classifying'.
The more AI I can do, the greater my capacity to create.
It's AI/fp applied to blockchain that will be the amplifier for what I can create.

* Being able to perform data science should be quite trivial actually
The hard bits are being good at technology.
Being able to integrate things -- this is the hard bit.

* emacs must always be working and I must be using it to learn more improtant things

* I have to get into racket in a serious way

* Staying inside emacs is very fast
selected.el is lifechanging.

* I am trying to get better at these things:
- abstract algebra / haskell
- deep learning
- natural language processing
- creating DSLs

The way to creating DSLs is much like learning emacs.
It will happen with time as I need stronger macros.

Haskell and deep learning are more foreign and will require effort.

Natural Language Processing will require less effort and relies on my emacs environment.

* I have to be accumulating things that will be useful in the future
- nothing else

Accumulate:
- knowledge of haskell

There will be languages with syntax beyond haskell that I will have to learn.

* emacs lisp is extremely limited
I have to urgently move away from emacs lisp and on to racket.

* I should be able to make notes such as this in my glossary
I only need to be able to easily enter into that url and read from it.
It should not be a chore.

weight initialization
https://madaan.github.io/init/

* It's frustrating when I'm in zsh and I need to get some text from the terminal
Can I run zsh inside emacs very well?

* emacs lisp
https://www.reddit.com/r/emacs/comments/6qpbka/elisp_for_text_processing_in_buffers/

- for me, the basic problems are, from more critical to less:
- emacs cannot open large files. e.g. 10 megabytes file becomes very
  slow.
- emacs has to load whole file into memory. It cannot just read a line
  of a file. Basically, you can't use emacs to process say http server
  log files.
- emacs has problem with long lines. e.g. many modern lib generate
  html/js output all in 1 single line.
- elisp is at least 6 times slower than python ruby perl.
- emacs regex sucks. ① backslash problem. ② Unpredicable syntax table
  dependent e.g. for word. ③ Verbose syntax e.g. in 「[[:digit:]]」
  instead of 「\d」. ④ Less powerful.
- string lib sucks. Though, usually you'd use buffer functions, still, a
  robust string lib helps a lot.
- when using elisp as text processing script, many obscure details one
  has to pay attention to. e.g. you don't want to use find-file to open
  cuz that loads the major mode with syntax coloring, undo on, or lots
  packages have added hooks when a file is opened, need to possibly turn
  off auto backup, etc.
- the no raw string quote is painful. e.g. in perl/ruby you use single
  quote or q[], in python you use tripple. In elisp, you have to
  sprinkle backslashes into the string. Not practical when the string is
  long, such as comp lang code or regex code. (or you put the string
  into a file then read it in, but that's another inconvenience)

The emacs buffer type is far more powerful than string type. The
addition of “point” datatype and others, narrow to region, move/search
forward backward, insert/replace text anywhere, makes it far more
powerful than any regex. I thought i'd write all text processing in
elisp. But these days, i avoid it, unless i want to use it interactively
while in emacs.

PS thanks for citing my work.
xah

* I need to be building up functions that are important
I need haskell for this.
Haskell will make me a much stronger programmer.
Of that I have no doubt.
Don't *force* myself to write idiomatic haskell.
Just use it.
Use the language rather than be used by the language.

* Get the knowledge into me so I can dream about it
And think about it, in comfort and happiness.

* haskell sucks because
- it's slow
- it doesn't have any NL documentation. what does this bool do?
- it doesn't allow you to easily see the implementation of a function

* emacs inferior haskell process is broken
Whatever the fuck that means.

$HOME/notes2018/ws/playgrounds/haskell/read.hs

* I have to ensure that I get older I am feeling prepared
- nlp
- haskell (harder to justify)
- deep learning
- racket

Integrate all of this somehow.

* It's more important to learn racket and NLP than haskell

* There may be no shortcut to becoming proficient at Haskell
Start with simple projects.
Solve emacs bugs on the way to a more mature environment.

* Need to learn the debugging tools for any language I need to use a lot
- add tracing to function

* Like lemmings, have codes for loading into specific states

$MYGIT/ines/spacy-course/exercises

Load some text into specific states.

Try to get everything into vector form.

Only when I make someething cool should I do this.
Focus on meta stuff. Query lanugages.
Languages for generating stuff.
Lnaguages for learning rules.

* I should try to read papers and use spacy to do my note-taking

* It's more important to be actively using NLP software than to be searching for jobs
I should integrate some parts of spacy into my emacs environment.

* Is it possible to buy something without paying for it?
This is an example I should give somebody to describe how
- "bought and paid for" is not a tautology
- synonyms are only approximately equal
Someone may buy something with something that is destined to lose its value anyway.
Cheating the system means that something can be bought but not paid for.
A bug or loophole in some code.
Imperfections in the blockchain system may validate/legalise a transaction that was made dishonestly.

* Learn fp concepts and then I'll be able to control more complex things
The more fp I learn, the more abstract the things I will be able to understand.

* TODO IMPORTANT I must build up something similar to emacs but in racket or haskell
- buffers
- caching
- state
- loading

I would load it when I load emacs. emacs would use it.

* Try to do everything in emacs
All my NLP.

* Rules are discrete, but the world is continuous

- interpretation
- interpolation
- filling-in

* I must always be able to reconcile all the fields of knowledge
This fills in all the holes. It interpolates.

Everything must be:
- understandable
- based on functional programming
  fp is my understanding
- Deep learning is the b-line between everything
- NLP is the DSL
- blockchain is the

* Somehow I have to aquire both practical skills and deep knowledge of algorithms relating to a specific topic

* I have to choose what goes in -- ensure I am watching haskell/math/nlp

* I should be building translation tools into my own terminal environment
Make it harder, then make tools to make it easier.

* I have to focus very much on NLP and haskell

* This is the perfect job for met
https://www.facebook.com/careers/jobs/1978590319117340/

* Learning haskell is more important than learning commands to things
There are lots of commands in the world but there is no need to learn them.
Build pure functional programming.

* Make functions for all sorts of things
I don't even really need to implement search tools for those functions.
But I need to access them.

* I am writing a lot of bash
All of my code needs to be haskell from now on.

* The next step is to get to expert-level haskell

* I don't owe them any more than what I have given them
Start having fun.

* I must focus on haskell for a while
I should probably get a haskell job.
This is probably for the best, to be honest.

* Load the computer quickly and start learning immediately
I need to be able to start and stop the computer quickly. Pick it up and learn.

* Just get good at haskell
I will see that I'll be able to do everything through haskell one day.
There is no need for python.

Emacs is amazing.
And emacs.

If I've identified haskell as something important to learn, that means I can feel secure getting a job in it.
However it's unlikely that I could get a job in a language that I do not know.

* If I only had a way to rapidly search for examples by snippet name
This would allow me to learn programming languages very quickly.
And it's important to keep this up.

* I should be purposefully obscuring my own development environment and then trying to clear it up with deep learning

* Try to keep everything programmable
My Chinese syntax highlighting is not great like that.
It's still awesome.

* Anything is more importantant than the alternative if I have integrated it and can use it easily

* It might be nice to convert languages without a perfect translation so you get something that is easier to understand
e.g. a non-perfect translation from chinese to english
Non-perfect is good because we do not want English idioms.

Is there a way to remove all English idioms from some text? Perhaps this is the proper way?

* Use what I know to learn haskell

* I should be learning only haskell functions
This is important for the longetivity of my code.
The cool thing is that learning basic functions are super powerful if they are pure.

* I must build tools for learning more about haskell
This is the fastest path to learning haskell.

* At work I should be given tasks to solve in all the languages we deem to be important
Haskell should definitely be one of those.

* I have to combine all my scripts into haskell racket functions
Then combine the racket scripts into haskell functions.

The sooner I understand how to use haskell to solve tasks with library functions, the better.

* Can't progress like this
Need to start importing stuff. Write terse code.

Things must be available by default.

I think I need to make racket scripts. Even if they use bash underneath.

#+BEGIN_SRC sh
  is_tty() {
      # If stout is a tty
  