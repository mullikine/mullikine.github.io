<dl>
<dt>Other formats</dt>
<dd><code>Word</code> <a href="https://mullikine.github.io/ox-hugo/application-to-fortescue-metals-group.doc">application-to-fortescue-metals-group.doc</a><br />
<code>PDF</code> <a href="https://mullikine.github.io/ox-hugo/application-to-fortescue-metals-group.pdf">application-to-fortescue-metals-group.pdf</a>
</dd>
</dl>
<p>To Fortescue Metals Group,</p>
<p>Please consider me for the position of <strong>Senior Software Tester</strong>.</p>
<p>In the specific area of <strong>HIL Testing</strong> I have 2 years of solid experience from working at Crown Robotics Technology Center ( <strong>RTC</strong> ) in Penrose, Auckland. I also have a year of building and testing a C++ application for <strong>TracMap</strong> (details below). I have also accrued a significant amount of testing experience over the last 8 years working as a Software Engineer on embedded software, software as a service (SASS) and continuous integration (CI) as a service.</p>
<p>I have been a practicing software engineer for over a decade now with my first job in web development in 2005. I've been programming for 20 years altogether. I hope that you will look past the chink in my armour which is the amount of HIL Testing experience I have and help me to take the next step in my career.</p>
<p>I believe I can perform this task and will continue to make myself useful after the first year.</p>
<p>Yours sincerely,</p>
<p>Shane Mulligan</p>
<h2 id="testing-experience">Testing experience</h2>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Company</th>
<th align="left">Context</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>HIL Testing</strong></td>
<td align="left"><strong>Crown</strong></td>
<td align="left">Localisation, smoke, integration tests.</td>
<td align="left">2 years (2016, 2017)</td>
</tr>
<tr class="even">
<td align="left"><strong>C++ testing</strong></td>
<td align="left"><strong>TracMap</strong></td>
<td align="left">C++ application testing</td>
<td align="left">2011</td>
</tr>
<tr class="odd">
<td align="left"><strong>JavaScript testing</strong></td>
<td align="left"><strong>TracMap</strong></td>
<td align="left">SAAS testing</td>
<td align="left">2012</td>
</tr>
<tr class="even">
<td align="left"><strong>Python testing</strong></td>
<td align="left"><strong>TracMap</strong></td>
<td align="left">SAAS testing</td>
<td align="left">2013</td>
</tr>
<tr class="odd">
<td align="left"><strong>C++ unit tests</strong></td>
<td align="left"><strong>Crown</strong></td>
<td align="left">C++ application dev</td>
<td align="left">2015, 2016</td>
</tr>
<tr class="even">
<td align="left"><strong>Python testing</strong></td>
<td align="left"><strong>Crown</strong></td>
<td align="left">Selenium, HIL</td>
<td align="left">2016, 2017</td>
</tr>
<tr class="odd">
<td align="left"><strong>Golang testing</strong></td>
<td align="left"><strong>CodeLingo</strong></td>
<td align="left"></td>
<td align="left">2018</td>
</tr>
<tr class="even">
<td align="left"><strong>Experience with Gitlab CI/CD tools</strong></td>
<td align="left"><strong>CodeLingo</strong></td>
<td align="left">Automating CodeLingo</td>
<td align="left">8 months (2018, 2019)</td>
</tr>
<tr class="odd">
<td align="left"><strong>Experience with code change tracking</strong></td>
<td align="left"><strong>Crown</strong></td>
<td align="left">Jenkins</td>
<td align="left">2016</td>
</tr>
</tbody>
</table>
<h2 id="summary-of-crown-work">Summary of Crown work</h2>
<dl>
<dt>Preamble</dt>
<dd><p>While I was at Crown I managed to automate everything that I did and put it all under my terminal system; I can't demonstrate this but from my blog you may infer what I have the potential to make.</p>
<p>I turned managing the HIL rigs into a fully automated process. I was very proud of my work. When I started out, the HIL rigs were a black box; An engineer would bring a keyboard to a HIL rig, connect a monitor to it and work through a featureless shell.</p>
<p>Once I had fully automated the HIL rigs, I could launch any jenkins job from my terminal, search for and relaunch jobs using a fuzzy finder, restart hardware components, log into various components via other components, even when IP addresses changed, etc.; I logged all HIL rig jobs.</p>
<p>Also, I was able to integrate all of the research trucks seamlessly into the same environment which I used to manage the HIL rigs. I refrained from doing so, however, unless there was a request to do so.</p>
<p>The trucks then benefited from the same search and debugging tooling I had made; If anyone required logs generated from EBL, I would know exactly how to find them, which ones were the newest, etc., what was inside them (I had an H5 log parser).</p>
<p>I was not assigned an assistant so the grunt work of managing the HIL rigs and automating them was solely my responsibility.</p>
</dd>
</dl>
<p>The majority of my experience in HIL testing comes from working at Crown on their localisation software; EBL and Dual-Mode. For the my first 2 years there I recall the following responsibilities and tasks:</p>
<ul>
<li>Create documentation on the Wiring Loom, and components (software and hardware).</li>
<li>Document and be the source of information on the capabilities of each of the 8 HIL rigs.</li>
<li>Create specifications for new HIL rigs to be built to requirements</li>
<li>Maintain the operational status of the HIL rigs.</li>
<li>Maintain the existing HIL tests.
<ul>
<li>Update system software and HIL test dependencies, fix broken code as a result of updates, new code, patches or new hardware.</li>
</ul></li>
<li>Report on the operational status of the HIL rigs.</li>
<li>Classifying and debugging test failures on the HIL rigs.
<ul>
<li>RTM computer (several revisions with varying capabilities)
<ul>
<li>EBL (C++ application)</li>
<li>Other servers running on the RTM</li>
</ul></li>
<li>Selenium (EBL web front-end automation)</li>
<li>HIL components
<ul>
<li>Arduino</li>
<li>Wifi attenuator</li>
</ul></li>
<li>Logging everything and ensuring those logs are searchable. I used SphinxSearch for this.</li>
</ul></li>
<li>Creating workarounds for HIL rig failures
<ul>
<li>Lighting problems.</li>
</ul></li>
<li>Find the root cause of failures which may have gone back months or hundreds of builds/revisions ago. I built a database for this and search commands.</li>
<li>Debug network faults in the HIL rigs.</li>
<li>Debug failing Python tests.</li>
<li>Analyse logs from the HIL rigs</li>
<li>Create new jenkins jobs for new tests including:
<ul>
<li>The testing of new hardware.</li>
<li>The testing of Gazebo simulations.</li>
</ul></li>
<li>Integrate new jobs for and including:
<ul>
<li>Dual Mode.</li>
<li>Projects from the interns.</li>
</ul></li>
<li>Run a development/experimental jenkins server.</li>
<li>Look into Atlassian Bamboo.</li>
<li>Look into ElasticSearch and LogStash.</li>
<li>Manage jenkins:
<ul>
<li>Extending Jenkins to provide more information for developers.</li>
<li>C++ application compilation / build matrix</li>
<li>Restart servers.</li>
</ul></li>
<li>Analyse logs to
<ul>
<li>Look for the cause of failure.</li>
<li>Find the point of failure from the top down.
<ul>
<li>Jenkins &gt; Python &gt; C++ &gt; Hardware.</li>
</ul></li>
</ul></li>
<li>Delegate tasks to other developers for fixing tests.</li>
</ul>
<h3 id="some-innovations-i-made">Some innovations I made</h3>
<p>I automated the HIL rigs so that everything was operational from my own machine. I could inspect any part of the HIL rig system in seconds without opening up a web browser. I built emacs modes and a filesystem.</p>
<h4 id="search-engine">Search engine</h4>
<p><img src="file:croogle.png" /></p>
<p>This included:</p>
<ul>
<li>A query language</li>
<li>Generated graphs to keep track of and correlate errors</li>
</ul>
<p><img src="file:events-verify.png" /></p>
<p>I built my own LogStash-like database.</p>
<p>I set up this search engine to assist me with debugging errors from many different sources. This is before LogStash was an option.</p>
<h4 id="i-built-new-hil-test-tooling-for-debugging-and-management">I built new HIL test tooling for debugging and management</h4>
<ul>
<li>I automated the HIL rigs for remote management.</li>
<li>Record video of test rigs with Python traces as subtitles.</li>
<li>Allow for interactively debugging the HIL tests, remotely. This was done on-site initially.</li>
</ul>
<h3 id="my-typical-day">My typical day</h3>
<p>On a daily basis I would be writing mainly Python and bash, but also JavaScript, awk and GNU Makefiles, assisting Java and C++ developers with running their code on the HIL rigs.</p>
<h3 id="other-languages-i-encountered">Other languages I encountered</h3>
<p>I also had to use Plan9 Makefiles, C, C++, Golang and Groovy (for jenkins).</p>
<h3 id="infolink">InfoLink</h3>
<p>In the last 6 months of working at Crown I was involved in the development of their mounted control panel, InfoLink. I made the startup screen in C, the software update system in bash and javascript and helped a colleague with a Basler 3D camera in C++.</p>
<p>While working on InfoLink I got a small amount of experience writing tests with the mocking framework <code>trompeloeil</code>.</p>
<h4 id="testing-infolink-on-actual-trucks">Testing InfoLink on actual Trucks</h4>
<p>The process of testing out new versions of the InfoLink firmware was very tedious and a little bit of a black box which means frequent trips to and from the truck. But I automated building and deployment of the <code>js/node/electron</code> application to the truck and also the logging to and from the InfoLink server. This was so I was able to see the messages to and from the application and the server. Keep in mind that this is all happening across multiple machines, but the information is right at hand while I am debugging.</p>
<h3 id="ebl-application-testing">EBL application testing</h3>
<p>I had experience writing unit tests in C++ using the <code>catch</code> library.</p>
<h3 id="ebl-hil-testing">EBL HIL testing</h3>
<p>I maintained HIL integration tests that utilised the <code>unittest</code> library.</p>
<h3 id="debugging">Debugging</h3>
<p>I was able to combine all text logs including:</p>
<ul>
<li>python unittest</li>
<li>application build versions from git</li>
<li>jenkins metadata</li>
<li>selenium</li>
<li>firefox and chrome errors</li>
<li>hardware versions</li>
<li>EBL application errors</li>
<li>C++ tracing</li>
<li>javascript (v8) logging</li>
<li>kernel messages</li>
<li>etc.</li>
</ul>
<p>into a single log streaming on the screen while testing.</p>
<p>I built the same environment to also provide me with a python shell mid-test as soon as there was an error on jenkins.</p>
<p>I interfaced my debugging environment to jenkins' build directories.</p>
<p>To make these things I used:</p>
<ul>
<li>UNIX tools to achieve my logging goals (ssh, awk, jq, sed, etc.).</li>
<li>Python interact, python trace, Xpra, Xephyr, etc. to achieve my interactivity for HIL tests.</li>
</ul>
<h3 id="c">C++</h3>
<p>While I was at Crown I was also the person people came to when they needed to find their C++ build logs, C++ coverage data, <code>h5</code> logs (usually for searching for <code>lost events</code>).</p>
<h2 id="summary-of-tracmap-work">Summary of TracMap work</h2>
<p>My first exposure to HIL and SIL was at TracMap where I developed application firmware in C++ without supervision under various combinations of hardware and software components.</p>
<h3 id="tm4tm5-application-firmware">TM4/TM5 application firmware</h3>
<p>The test matrix factors would have looked something like this:</p>
<table>
<thead>
<tr class="header">
<th align="left">Build toolchain</th>
<th align="left">Application Firmware</th>
<th align="left">Head unit type</th>
<th align="left">GPS type</th>
<th align="left">Display vendor</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">metabuild (busybox shell)</td>
<td align="left">Flight v1</td>
<td align="left">TM4 (real)</td>
<td align="left">gpssim (c/ncurses, flight sim + speader)</td>
<td align="left">vendor 1: expensive, bright and gossy</td>
</tr>
<tr class="even">
<td align="left">sysman (perl)</td>
<td align="left">Flight v2</td>
<td align="left">TM5 (real)</td>
<td align="left">gpssim (javascript, replaying logs)</td>
<td align="left">vendor 2: cheap, bright and glossy but with a flaw</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">Ground v1</td>
<td align="left">TM4 (VirtualBox)</td>
<td align="left">real (garmin)</td>
<td align="left">vendor 3: mid-range, matte, well rounded</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">Ground v2</td>
<td align="left">TM5 (VirtualBox)</td>
<td align="left">real (other vendors, etc.)</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<h3 id="broken-headunits">Broken headunits</h3>
<p>I also diagnosed problems with broken headunits as they were returned to TracMap for servicing.</p>
<h3 id="traclink---development-and-testing">TracLink - Development and Testing</h3>
<p>This is an online service for remotely interacting with trucks, reporting and planning.</p>
<p>I wrote unit tests in JavaScript using the <code>jasmine</code> testing framework.</p>
<h3 id="saas">SAAS</h3>
<p>I had a year of web development developing TracLink, a SAAS product for interacting with the fleet.</p>
<p>This involved:</p>
<ul>
<li>writing database migration scripts in SQL</li>
<li>extending the database</li>
<li>writing jasmine unit tests</li>
</ul>
<h3 id="automation">Automation</h3>
<p>I had automated the entire building, testing and debugging process of the TM5 head unit; It could all be done remotely via a terminal, including the GPS/flight simulation software which was an ncurses program.</p>
<p>I stuck to using terminal-based applications for everything I could, including miniterm for interacting with the GPS while decoding messages.</p>
<p>With regard to testing the head unit's user interface, I took extra time to get the application running on VirtualBox so could then stream it over SSH, and work from home if I wanted.</p>
<p>Over New Year's Day I took my laptop with me to a beach in the far reaches of NZ and did a little testing. One day I'd like to be controlling robots on the moon!</p>
<h2 id="summary-of-work-at-codelingo">Summary of work at CodeLingo</h2>
<dl>
<dt>Preamble</dt>
<dd><p>I started automating CodeLingo when I began the job.</p>
<p>Just like my work at Crown I managed to automate the entire platform except much quicker than last time.</p>
<p>I made 410 CodeLingo-specific scripts while I was working there and 2000 scripts for general automation of my terminal.</p>
<p>It's hard to talk about but I can provide provide access to my scripts on GitHub on request.</p>
<p>In the first month I automated the repository research phase of CodeLingo, before which relevant repositories had to be found manually. I used my GitHub search engine which I had built while studying a PgDip in 2018 to find repositories which were both active and valid and had the user defined specifications we needed to target. I then proceeded to automate the platform to run on these repositories.</p>
<p>Once it was established that I had automated the entire system we started a marketing campaign which lasted a month. We made automated bug fixes and pull requests to over 1000 repositories.</p>
<p>I was offered a permanent position but I declined citing it was too stressful and I needed to be paid more for the work I was doing.</p>
</dd>
</dl>
<p>---</p>
<p>I will defer to my blog articles about CodeLingo for the TLDR.</p>
<p><a href="https://mullikine.github.io/codelingo-vs-linters/summary/">CodeLingo vs Linters: TLDR // Bodacious Blog</a></p>
<p>I helped CodeLingo to document bugs, automate their platform, emails and also worked on a lexicon which can be imported into their DSL, CLQL.</p>
<p>I did some code generation, Google BigQuery, Golang, Python and bash.</p>
<p><a href="https://mullikine.github.io/posts/github-search-with-bigquery/">Tremendous Task: Searching for code on GitHub with BigQuery and GHTorrent // Bodacious Blog</a></p>
<h1 id="job-description-requirements">Job description requirements</h1>
<h2 id="develop-testing-procedures-for-new-projects">Develop testing procedures for new projects</h2>
<p>Yes, at Crown.</p>
<h2 id="experience-with-gitlab-cicd-tools">Experience with Gitlab CI/CD tools</h2>
<ul>
<li>Yes, I have automated lengthy processes with GitHub and Gitlab.</li>
<li>Also, I have scripts, CLI tools and emacs plugins which I use to interact with both GitHub and Gitlab.</li>
</ul>
<h2 id="experience-with-testing-c-code-base">Experience with testing C++ code base</h2>
<p>Yes.</p>
<h2 id="experience-with-gtest-suite-and-gmock">Experience with gtest suite and gmock</h2>
<p>I believe we used <code>catch</code> as our c++ testing framework and <code>trompeloeil</code> for mocking.</p>
<p>I was involved in creating tests but not selecting the testing technology.</p>
<h2 id="experience-with-docker">Experience with docker</h2>
<p>I started with linux containers circa. 2011. I have built scripts to deal with docker containers and kubernetes.</p>
<p>Here is an example of a workaround to do port forwarding for k8s when <code>kubefwd</code> would time out unexpectedly.</p>
<p>I had to build this in order to automate CodeLingo. Also I designed it for the other developers to use in their own workflows.</p>
<p>I've deemed the following code to be insensitive, but made some text replacements to be sure.</p>
<pre><code>  #!/bin/bash
  export TTY

  read -r -d &#39;&#39; hosts &lt;&lt;HEREDOC
  127.1.27.1 codelingo-ast-common codelingo-ast-common.lexicon codelingo-ast-common.lexicon.svc.cluster.local
  127.1.27.2 codelingo-ast-cpp codelingo-ast-cpp.lexicon codelingo-ast-cpp.lexicon.svc.cluster.local
  127.1.27.3 codelingo-ast-csharp codelingo-ast-csharp.lexicon codelingo-ast-csharp.lexicon.svc.cluster.local
  127.1.27.4 codelingo-ast-go codelingo-ast-go.lexicon codelingo-ast-go.lexicon.svc.cluster.local
  127.1.27.5 codelingo-ast-golint codelingo-ast-golint.lexicon codelingo-ast-golint.lexicon.svc.cluster.local
  127.1.27.6 codelingo-ast-php codelingo-ast-php.lexicon codelingo-ast-php.lexicon.svc.cluster.local
  127.1.27.7 codelingo-ast-phplint codelingo-ast-phplint.lexicon codelingo-ast-phplint.lexicon.svc.cluster.local
  127.1.27.8 codelingo-ast-python27 codelingo-ast-python27.lexicon codelingo-ast-python27.lexicon.svc.cluster.local
  127.1.27.9 codelingo-ast-python36 codelingo-ast-python36.lexicon codelingo-ast-python36.lexicon.svc.cluster.local
  127.1.27.10 codelingo-vcs-git codelingo-vcs-git.lexicon codelingo-vcs-git.lexicon.svc.cluster.local
  HEREDOC

  cathosts() {
      printf -- &quot;%s\n&quot; &quot;$hosts&quot;
  }

  sudo killall -9 kubefwd

  gateway_host=&quot;$1&quot;
  : ${gateway_host:=&quot;XXXXXXXXXXXXXXXXXX.XXXXXXXXX.compute.amazonaws.com&quot;}

  kubectl get pods --all-namespaces | grep &quot;^lexicon&quot; | grep &quot;Running&quot; | awk &#39;{print $2}&#39; | awk 1 | while IFS=$&#39;\n&#39; read -r pod_hash; do
  (
  exec 0&lt;/dev/null
  pod_name=&quot;$(printf -- &quot;%s&quot; &quot;$pod_hash&quot; | cut -d - -f1-3)&quot;
  local_ip=&quot;$(cathosts | grep -P &quot;\b$pod_name\b&quot; | awk &#39;{print $1}&#39;)&quot;
  remote_ip=&quot;$(kubectl describe pods &quot;$pod_hash&quot; -n lexicon | grep &quot;^IP:&quot; | awk &#39;{print $2}&#39;)&quot;
  ssh -fNT -L $local_ip:9999:$remote_ip:9999 &quot;$gateway_host&quot;
  ssh -fNT -L $local_ip:8888:$remote_ip:8888 &quot;$gateway_host&quot;
  )
  done
</code></pre>
<h2 id="sil-and-hil-testing-experience">SIL and HIL testing experience</h2>
<h3 id="codelingo">CodeLingo</h3>
<ul>
<li>Automated git bisect</li>
</ul>
<h2 id="experience-with-c-static-analysis-tools">Experience with C++ static analysis tools</h2>
<ul>
<li>Bullseye (C++ code coverage)</li>
<li>cppcheck</li>
<li>CodeLingo</li>
<li>Semmle</li>
</ul>
<h2 id="experience-with-code-change-tracking-traceability-and-auditing.">Experience with code change tracking, traceability and auditing.</h2>
<p>Yes, my debugging environment helped me to chase down errors to the specific git revision of a given project which caused them.</p>
<p>We used a git repository submodule system but given someone's jenkins build configuration, I was able to recombine it to test other parameters, including combinations of different application components.</p>
<ul>
<li>Jenkins (C++, python)</li>
<li>Go Modules (golang)</li>
</ul>
<p>While at CodeLingo, I maintained multiple builds of the CodeLingo system which meant that one of my machines would usually be operational during times when everyone else's was broken.</p>
<h2 id="release-management">Release management</h2>
<p>I was not reponsible for release management at Crown but I was responsible for caring for both the development and main jenkins servers. The development server moved at a different pace but I had to correlate errors <strong>between both</strong>.</p>
<p>I was however, involved in setting up jobs surrounding different stages of release and was the person who provided off-hand information on the current state.</p>
<h2 id="simulation-based-testing">Simulation based testing</h2>
<p>I have done some automation around Gazebo.</p>
<p>I helped in setting up Gazebo for use in the HIL rigs at Crown.</p>
<p>I automated all of the Xterms and logging from Gazebo. One problem I solved was with the Xterms actually.</p>
<p>Debugging Dual-Mode simulations with Gazebo remotely on HIL rigs was very impractical. The job ran autonomously but couldn't be interacted with.</p>
<p>I started by making it work on my own machine with all Xterms defering to run tmux instead. I did a similar thing at <code>CodeLingo</code>.</p>
<p>This replaces the <code>mate-terminal</code> program.</p>
<pre><code>  #!/bin/bash
  export TTY

  ( hs &quot;$(basename &quot;$0&quot;)&quot; &quot;$@&quot; 0&lt;/dev/null ) &amp;&gt;/dev/null

  pane_id=&quot;$(TMUX= tmux neww -n platform -P bash)&quot;

  export DISABLE_COLORIZE=y

  # Do not kill here unless I plan on restarting it
  docker kill $(docker ps -q)
  docker run -d -p 9411:9411 openzipkin/zipkin

  while [ $# -gt 0 ]; do opt=&quot;$1&quot;; case &quot;$opt&quot; in
      --tab) {
          shift

          name=
          command=zsh
          while [ $# -gt 0 ]; do opt=&quot;$1&quot;; case &quot;$opt&quot; in
              -t) {
                  name=&quot;$2&quot;
                  shift
                  shift
              }
              ;;

              -e) {
                  command=&quot;$2&quot;
                  shift
                  shift
              }
              ;;

              *) break;
          esac; done

          # Must use tm splits (beacuse it traps INT)

          new_pane_id=&quot;$(TMUX= tmux splitw -F &quot;#{pane_id}&quot; -P -t &quot;$pane_id&quot; &quot;trap &#39;&#39; INT; stty stop undef; stty start undef; export DISABLE_COLORIZE=$DISABLE_COLORIZE; pl $(aqf &quot;$command&quot;) | udl; $command; pak q&quot;)&quot;
          TMUX= tmux select-layout -t &quot;${pane_id}&quot; tiled

          echo &quot;$new_pane_id&quot; | ds -s -q &quot;matepane$name&quot;

          echo &quot;$name:$new_pane_id&quot;
      }
      ;;

      *) break;
  esac; done

  TMUX= tmux kill-pane -t &quot;${pane_id}&quot; # The original pane
  TMUX= tmux select-layout -t &quot;${pane_id}&quot; tiled
</code></pre>
<h1 id="in-summary">In summary</h1>
<p>In each of the 3 jobs listed that I have worked (TracMap, Crown and CodeLingo) I have managed to get to the stage where I could do my all my work through a single terminal window, which is how I like it!</p>
<p>Thanks for reading!</p>
