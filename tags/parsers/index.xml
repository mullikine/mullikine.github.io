<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>parsers on Bodacious Blog</title>
    <link>https://mullikine.github.io/tags/parsers/</link>
    <description>Recent content in parsers on Bodacious Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 25 Oct 2019 00:00:00 +1300</lastBuildDate>
    
	<atom:link href="https://mullikine.github.io/tags/parsers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>(WIP) Syntax transformers step by step</title>
      <link>https://mullikine.github.io/posts/monad-transformers-step-by-step/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/monad-transformers-step-by-step/</guid>
      <description>Demonstrate monad transformers Build an interpreter for the little language below. type Name = String -- variable names data Exp = Lit Integer -- expressions | Var Name | Plus Exp Exp | Abs Name Exp | App Exp Exp deriving (Show) data Value = IntVal Integer -- values | FunVal Env Name Exp deriving (Show) type Env = Map.Map Name Value -- mapping from names to values Add the header module Transformers where import Control.</description>
    </item>
    
    <item>
      <title>Write You A Haskell</title>
      <link>https://mullikine.github.io/posts/write-you-a-haskell/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/write-you-a-haskell/</guid>
      <description>This is just a casual writeup of WYAH as I read through it.
Prereading Glossary monad transformer You have an innermost monad (usually Identity or IO but you can use any monad). You then wrap monad transformers around this monad to make bigger, better monads. https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf It is possible to create custom monads simply by composing the necessary monad transformers. For example, if you need a monad with state and error handling, just take the StateT and ErrorT monad transformers and combine them.</description>
    </item>
    
  </channel>
</rss>