<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>parsers on Bodacious Blog</title>
    <link>https://mullikine.github.io/tags/parsers/</link>
    <description>Recent content in parsers on Bodacious Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Nov 2019 00:00:00 +1300</lastBuildDate>
    
	<atom:link href="https://mullikine.github.io/tags/parsers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Monad transformers</title>
      <link>https://mullikine.github.io/posts/monad-transformers/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/monad-transformers/</guid>
      <description>Original resource https://wiki.haskell.org/Meta-tutorial  grok haskell monad transformers  Original article http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html  State monad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  import Control.Monad.Identity import Control.Monad.State test1 = do a &amp;lt;- get modify (+1) b &amp;lt;- get return (a,b) test2 = do a &amp;lt;- get modify (++&amp;#34;1&amp;#34;) b &amp;lt;- get return (a,b) go1 = evalState test1 0 go2 = evalState test2 &amp;#34;0&amp;#34; :t go1 go1 :t go2 go2 &amp;#34;**************&amp;#34; :t get :i get &amp;#34;**************&amp;#34; :t evalState :i evalState   go1 :: (Integer, Integer) (0,1) go2 :: ([Char], [Char]) (&amp;#34;0&amp;#34;,&amp;#34;01&amp;#34;) &amp;#34;**************&amp;#34; get :: MonadState s m =&amp;gt; m s class Monad m =&amp;gt; MonadState s (m :: * -&amp;gt; *) | m -&amp;gt; s where get :: m s .</description>
    </item>
    
    <item>
      <title>Deconstructing IPTables-Metalanguage</title>
      <link>https://mullikine.github.io/posts/deconstructing-iptables-metalanguage/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/deconstructing-iptables-metalanguage/</guid>
      <description>Main.hs 1 2 3 4 5 6 7  ./Main.hs:4:import Test.Framework (defaultMain, testGroup) ./Main.hs:6:import Test.Framework.Providers.QuickCheck2 (testProperty) ./Main.hs:11:import Text.ParserCombinators.Parsec ./Main.hs:13:import Text.IptablesMetalanguage.Types ./Main.hs:14:import Text.IptablesMetalanguage.Parser ./Main.hs:15:import Text.IptablesMetalanguage.Print ./Main.hs:17:import GHC.Word   Test.Framework http://hackage.haskell.org/package/HTF
Tutorial http://hackage.haskell.org/package/HTF-0.14.0.0/docs/Test-Framework-Tutorial.html
defaultMain testGroup Parser.hs 1 2 3 4 5 6 7 8  ./src/Text/IptablesMetalanguage/Parser.hs:4:import Text.IptablesMetalanguage.Types ./src/Text/IptablesMetalanguage/Parser.hs:5:import Control.Applicative ((&amp;lt;$&amp;gt;)) ./src/Text/IptablesMetalanguage/Parser.hs:6:import Control.Monad.Error ./src/Text/IptablesMetalanguage/Parser.hs:7:import Data.Bits ./src/Text/IptablesMetalanguage/Parser.hs:8:import Data.Set (fromList) ./src/Text/IptablesMetalanguage/Parser.hs:9:import Data.Word ./src/Text/IptablesMetalanguage/Parser.hs:10:import Safe ./src/Text/IptablesMetalanguage/Parser.hs:11:import Text.ParserCombinators.Parsec   Types.hs 1 2  ./src/Text/IptablesMetalanguage/Types.hs:4:import Data.</description>
    </item>
    
    <item>
      <title>Rosie Pattern Matching Language (RPL)</title>
      <link>https://mullikine.github.io/posts/rosie-pattern-matching-language/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/rosie-pattern-matching-language/</guid>
      <description>1 2 3 4 5 6 7 8 9  Rosie Pattern Matching Language RPL A language for writing PEG grammars, which are by definition both greedy and possessive. Parsing Expression Grammars PEG PEG languages are greedy and possessive.   extract ip addresses This file defines the ip address.
https://gitlab.com/rosie-pattern-language/rosie/blob/master/rpl/net.rpl
1  dmesg | rosie grep -o subs net.ipv4   7.35.177.61 7.35.177.61 extract email addresses RPL is greedy, possessive and its grammar libraries are usually designed to exhaust all possible (as opposed to commonly expected) matches, according to some spec.</description>
    </item>
    
    <item>
      <title>Write You A Haskell</title>
      <link>https://mullikine.github.io/posts/write-you-a-haskell/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/write-you-a-haskell/</guid>
      <description>This is just a casual writeup of WYAH as I read through it.
Prereading Glossary monad transformer You have an innermost monad (usually Identity or IO but you can use any monad). You then wrap monad transformers around this monad to make bigger, better monads. https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf It is possible to create custom monads simply by composing the necessary monad transformers. For example, if you need a monad with state and error handling, just take the StateT and ErrorT monad transformers and combine them.</description>
    </item>
    
    <item>
      <title>CodeLingo vs Linters</title>
      <link>https://mullikine.github.io/codelingo-vs-linters/main/</link>
      <pubDate>Fri, 05 Oct 2018 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/codelingo-vs-linters/main/</guid>
      <description>Making tenets with CLQL that do the job of existing linters I started learning Go and CodeLingo / CLQL at the same time, so while I have found it generally easy and straightforward to create these tenets, I feel like I could&amp;rsquo;ve knocked them out even faster if I didn&amp;rsquo;t need to look up answers to questions such as &amp;lsquo;what is an interface in golang?&amp;rsquo;, for example. The process has been intuitive; I think in part to having a good naming convention.</description>
    </item>
    
    <item>
      <title>CodeLingo vs Linters: TLDR</title>
      <link>https://mullikine.github.io/codelingo-vs-linters/summary/</link>
      <pubDate>Fri, 05 Oct 2018 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/codelingo-vs-linters/summary/</guid>
      <description>Tenet&amp;rsquo;s are 10x shorter and faster to write than Linters Comparison of size in code
   Lines (CL) Lines (L) Words (CL) Words (L) Bytes (CL) Bytes (L) Byte % (CL/L) Tenet name (CL) linter name (L)     18 681 49 2084 524 15616 3.36% unconvert unconvert   19 110 64 275 580 2198 26.39% init gochecknoinits   18 136 67 353 623 2307 27.</description>
    </item>
    
  </channel>
</rss>