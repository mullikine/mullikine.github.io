<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>parsers on Bodacious Blog</title>
    <link>https://mullikine.github.io/tags/parsers/</link>
    <description>Recent content in parsers on Bodacious Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Sep 2020 00:00:00 +1200</lastBuildDate><atom:link href="https://mullikine.github.io/tags/parsers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Generating hyperlinks for glossaries and other parsers in emacs</title>
      <link>https://mullikine.github.io/posts/generating-hyperlinks-for-glossaries-and-other-parsers-in-emacs/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +1200</pubDate>
      
      <guid>https://mullikine.github.io/posts/generating-hyperlinks-for-glossaries-and-other-parsers-in-emacs/</guid>
      <description>TL;DR: Build a wiki, but far more powerful  I would like to be reminded of things as I read, like a wiki, but better. I would like to see a glossary of the words I have learned. I would like to know at a moment&amp;rsquo;s glance what I have already read and understood. I would like to be reminded of important things as I&amp;rsquo;m having a conversation.  Great for  Reading books Keeping and navigating a glossary extremely easily Procedurally/generatively navigating text (the applications are endless)  Enter, emacs Demonstration</description>
    </item>
    
    <item>
      <title>parsing c&#43;&#43; with python</title>
      <link>https://mullikine.github.io/posts/parsing-c-with-python/</link>
      <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/parsing-c-with-python/</guid>
      <description>Example https://pygccxml.readthedocs.io/en/master/examples/templates/example.html  C++ is notoriously difficult to parse.
parse-cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #!/bin/bash export TTY ( hs &amp;#34;$(basename &amp;#34;$0&amp;#34;)&amp;#34; &amp;#34;$@&amp;#34; &amp;#34;#&amp;#34; &amp;#34;&amp;lt;==&amp;#34; &amp;#34;$(ps -o comm= $PPID)&amp;#34; 0&amp;lt;/dev/null ) &amp;amp;&amp;gt;/dev/null stdin_exists() { ! [ -t 0 ] &amp;amp;&amp;amp; ! test &amp;#34;$(readlink /proc/$$/fd/0)&amp;#34; = /dev/null } if stdin_exists; then fp=&amp;#34;$(tf cpp)&amp;#34; set -- &amp;#34;$fp&amp;#34; &amp;#34;$@&amp;#34; exec &amp;lt;&amp;amp;1 fi fp=&amp;#34;$1&amp;#34; test -f &amp;#34;$fp&amp;#34; || exit 1 x -sh &amp;#34;parse-cpp.</description>
    </item>
    
    <item>
      <title>Updating Trigger Studio for Age of Empires II: DE</title>
      <link>https://mullikine.github.io/posts/ts-aoe2de/</link>
      <pubDate>Sat, 27 Jun 2020 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/ts-aoe2de/</guid>
      <description>Credits Without the help of dderevjanik and KSneijders, this update would not be possible.
  dderevjanik
 http://dderevjanik.github.io/agescx/formatscx/#format    KSneijders
 https://github.com/KSneijders/AoE2ScenarioParser    Update: &amp;lt;2020-06-27 Sat&amp;gt; Using AoE2ScenarioParser by KSneijders Extract a trigger into JSON using the python library.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152  { &amp;#34;_TriggerObject__description&amp;#34;: &amp;#34;\u0000&amp;#34;, &amp;#34;_TriggerObject__short_description&amp;#34;: &amp;#34;\u0000&amp;#34;, &amp;#34;_name&amp;#34;: &amp;#34;StartYearCountdown\u0000&amp;#34;, &amp;#34;condition_order&amp;#34;: [ 0 ], &amp;#34;conditions&amp;#34;: [ { &amp;#34;ai_signal&amp;#34;: -1, &amp;#34;amount_or_quantity&amp;#34;: 0, &amp;#34;area_1_x&amp;#34;: -1, &amp;#34;area_1_y&amp;#34;: -1, &amp;#34;area_2_x&amp;#34;: -1, &amp;#34;area_2_y&amp;#34;: -1, &amp;#34;comparison&amp;#34;: -1, &amp;#34;condition_type&amp;#34;: 4, &amp;#34;inverted&amp;#34;: -1, &amp;#34;next_object&amp;#34;: -1, &amp;#34;object_group&amp;#34;: -1, &amp;#34;object_list&amp;#34;: 826, &amp;#34;object_type&amp;#34;: -1, &amp;#34;player&amp;#34;: 0, &amp;#34;py/object&amp;#34;: &amp;#34;AoE2ScenarioParser.</description>
    </item>
    
    <item>
      <title>Summary of &#39;CSC324: Welcome to CSC324!&#39;</title>
      <link>https://mullikine.github.io/posts/summary-of-csc324-welcome-to-csc324/</link>
      <pubDate>Sat, 06 Jun 2020 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/summary-of-csc324-welcome-to-csc324/</guid>
      <description>Original article CSC324: Welcome to CSC324! Original notes https://www.cs.toronto.edu/~david/csc324/csc324%5Fnotes.pdf   1 2 3 4 5 6 7 8 9 10 11  model of computation [#computability theory] [#computational complexity theory] A model which describes how an output of a mathematical function is computed given an input. A model describes how units of computations, memories, and communications are organized.   Arithmetic expressions Haskell data structures are able to easily and directly represent BNF-style grammars (Google Books).</description>
    </item>
    
    <item>
      <title>An exposition of racket languages</title>
      <link>https://mullikine.github.io/posts/an-exposition-of-racket-languages/</link>
      <pubDate>Sat, 30 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/an-exposition-of-racket-languages/</guid>
      <description>Firstly, add to emacs a way of selecting the racket language  Languages to add:  racket rackjure hackett sicp rash    Emacs lisp code 1  (&amp;#34;L&amp;#34; (hot-expand &amp;#34;&amp;lt;s&amp;#34; &amp;#34;racket-sublang&amp;#34;) &amp;#34;racket&amp;#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  (defun hot-expand (str &amp;amp;optional mod header) &amp;#34;Expand org template. STR is a structure template string recognised by org like &amp;lt;s.</description>
    </item>
    
    <item>
      <title>Review of &#39;Khanlou | Regexes vs Combinatorial Parsing&#39;</title>
      <link>https://mullikine.github.io/posts/review-of-khanlou-regexes-vs-combinatorial-parsing/</link>
      <pubDate>Thu, 28 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/review-of-khanlou-regexes-vs-combinatorial-parsing/</guid>
      <description>Original article Khanlou | Regexes vs Combinatorial Parsing  Work in progress
1 2  inscrutable Impossible to understand or interpret.    Regex  inscrutable not composable requires type interpretation    There&amp;rsquo;s actually not a lot in the original blog post.</description>
    </item>
    
    <item>
      <title>Using Facebook&#39;s Duckling parser</title>
      <link>https://mullikine.github.io/posts/using-facebook-s-duckling-parser/</link>
      <pubDate>Mon, 25 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/using-facebook-s-duckling-parser/</guid>
      <description>Demonstration 
Obtain the docker image 1  docker pull rasa/duckling   Create duckling-parse script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  #!/bin/bash export TTY input=&amp;#34;$(urlencode)&amp;#34; set -m ( unbuffer docker \  run \  --name duckling-container \  --rm \  --network=host \  --entrypoint= \  rasa/duckling:latest \  duckling-example-exe -p 8000 --no-access-log --no-error-log ) &amp;amp;&amp;gt;/dev/null &amp;amp; sleep 2 /usr/bin/curl -XPOST http://0.</description>
    </item>
    
    <item>
      <title>Using GitHub&#39;s Semantic parser</title>
      <link>https://mullikine.github.io/posts/using-github-semantic-parser/</link>
      <pubDate>Mon, 25 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/using-github-semantic-parser/</guid>
      <description>Links https://github.com/github/semantic#usage Related articles Overview of the semantic parser // Bodacious Blog  Glossary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  github semantic =semantic= is a Haskell library and command line tool for parsing, analyzing, and comparing source code. - Reads blobs. - Generates parse trees for those blobs with tree-sitter. - Assigns those trees into a generalized representation of syntax.</description>
    </item>
    
    <item>
      <title>Parsr</title>
      <link>https://mullikine.github.io/posts/parsr/</link>
      <pubDate>Tue, 21 Jan 2020 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/parsr/</guid>
      <description>Playing around with lazydocker, Parsr and jq 
Running the parser 1  cd &amp;#34;$MYGIT/axa-group/Parsr/docs&amp;#34;; npm run run:debug -- --input-file samples/bitcoin.pdf --output-folder dist/ --document-name example --config server/defaultConfig.json --pretty-logs   1  vs $MYGIT/axa-group/Parsr/dist/example.txt   1  cat $MYGIT/axa-group/Parsr/dist/example.json | jiq   Parsr is kinda cool It parses documents, provides you with a gui to find what you want and then a json parse tree.
  1  cat $MYGIT/axa-group/Parsr/dist/example.</description>
    </item>
    
    <item>
      <title>Review of &#39;Grammars for programming languages - Mikhail Barash - Medium&#39;</title>
      <link>https://mullikine.github.io/posts/review-of-grammars-for-programming-languages-mikhail-barash-medium/</link>
      <pubDate>Tue, 21 Jan 2020 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/review-of-grammars-for-programming-languages-mikhail-barash-medium/</guid>
      <description>Original article https://medium.com/@mikhail.barash.mikbar/grammars-for-programming-languages-fae3a72a22c6 See also https://mullikine.github.io/posts/rosie-pattern-matching-language/  CFG (context-free grammars) When syntax of programming languages is communicated CGFs are a lingua franca.
They define structure of syntax, but cannot express static semantics.
Limitations Soon after context-free grammars had been introduced, it became apparent that their expressive power is limited.
In 1962, Floyd has shown that Algol is not a context-free language and thus cannot be defined by a context-free grammar.</description>
    </item>
    
    <item>
      <title>Monad transformers</title>
      <link>https://mullikine.github.io/posts/monad-transformers/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/monad-transformers/</guid>
      <description>Original resource https://wiki.haskell.org/Meta-tutorial  grok haskell monad transformers  Original article http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html  State monad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import Control.Monad.Identity import Control.Monad.State test1 = do a &amp;lt;- get modify (+1) b &amp;lt;- get return (a,b) test2 = do a &amp;lt;- get modify (++&amp;#34;1&amp;#34;) b &amp;lt;- get return (a,b) go1 = evalState test1 0 go2 = evalState test2 &amp;#34;0&amp;#34; :t go1 go1 :t go2 go2 &amp;#34;**************&amp;#34; :t get :i get &amp;#34;**************&amp;#34; :t modify :i modify &amp;#34;**************&amp;#34; :t evalState :i evalState   go1 :: (Integer, Integer) (0,1) go2 :: ([Char], [Char]) (&amp;#34;0&amp;#34;,&amp;#34;01&amp;#34;) &amp;#34;**************&amp;#34; get :: MonadState s m =&amp;gt; m s class Monad m =&amp;gt; MonadState s (m :: * -&amp;gt; *) | m -&amp;gt; s where get :: m s .</description>
    </item>
    
    <item>
      <title>Deconstructing IPTables-Metalanguage</title>
      <link>https://mullikine.github.io/posts/deconstructing-iptables-metalanguage/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/deconstructing-iptables-metalanguage/</guid>
      <description>Main.hs 1 2 3 4 5 6 7  ./Main.hs:4:import Test.Framework (defaultMain, testGroup) ./Main.hs:6:import Test.Framework.Providers.QuickCheck2 (testProperty) ./Main.hs:11:import Text.ParserCombinators.Parsec ./Main.hs:13:import Text.IptablesMetalanguage.Types ./Main.hs:14:import Text.IptablesMetalanguage.Parser ./Main.hs:15:import Text.IptablesMetalanguage.Print ./Main.hs:17:import GHC.Word   Test.Framework http://hackage.haskell.org/package/HTF
Tutorial http://hackage.haskell.org/package/HTF-0.14.0.0/docs/Test-Framework-Tutorial.html
defaultMain testGroup Parser.hs 1 2 3 4 5 6 7 8  ./src/Text/IptablesMetalanguage/Parser.hs:4:import Text.IptablesMetalanguage.Types ./src/Text/IptablesMetalanguage/Parser.hs:5:import Control.Applicative ((&amp;lt;$&amp;gt;)) ./src/Text/IptablesMetalanguage/Parser.hs:6:import Control.Monad.Error ./src/Text/IptablesMetalanguage/Parser.hs:7:import Data.Bits ./src/Text/IptablesMetalanguage/Parser.hs:8:import Data.Set (fromList) ./src/Text/IptablesMetalanguage/Parser.hs:9:import Data.Word ./src/Text/IptablesMetalanguage/Parser.hs:10:import Safe ./src/Text/IptablesMetalanguage/Parser.hs:11:import Text.ParserCombinators.Parsec   Types.hs 1 2  ./src/Text/IptablesMetalanguage/Types.hs:4:import Data.Set .</description>
    </item>
    
    <item>
      <title>Overview of the semantic parser</title>
      <link>https://mullikine.github.io/posts/adding-new-languages-to-semantic/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/adding-new-languages-to-semantic/</guid>
      <description>Glossary 1 2 3 4 5 6 7  expression problem The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts).   Adding new languages to Semantic  Original article https://github.com/github/semantic/blob/master/docs/adding-new-languages.md  Adding new languages and syntax requires no changes to existing code.</description>
    </item>
    
    <item>
      <title>Rosie Pattern Matching Language (RPL)</title>
      <link>https://mullikine.github.io/posts/rosie-pattern-matching-language/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/rosie-pattern-matching-language/</guid>
      <description>Simple associativity and precedence rules All RPL operators are right-associative  expressions etc.  Binary operators have equal precedence in RPL bracket expressions Brackets behave very much like parentheses and braces.
It means that the expressions e1 … en can be any RPL expressions.
It means that extra layers of brackets around an expression do not change its meaning.
1 2 3 4 5 6 7 8  -- a sequence of expressions (the pliers ie.</description>
    </item>
    
    <item>
      <title>CodeLingo vs Linters</title>
      <link>https://mullikine.github.io/codelingo-vs-linters/main/</link>
      <pubDate>Fri, 05 Oct 2018 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/codelingo-vs-linters/main/</guid>
      <description>Making tenets with CLQL that do the job of existing linters I started learning Go and CodeLingo / CLQL at the same time, so while I have found it generally easy and straightforward to create these tenets, I feel like I could&amp;rsquo;ve knocked them out even faster if I didn&amp;rsquo;t need to look up answers to questions such as &amp;lsquo;what is an interface in golang?&amp;rsquo;, for example. The process has been intuitive; I think in part to having a good naming convention.</description>
    </item>
    
    <item>
      <title>CodeLingo vs Linters: TLDR</title>
      <link>https://mullikine.github.io/codelingo-vs-linters/summary/</link>
      <pubDate>Fri, 05 Oct 2018 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/codelingo-vs-linters/summary/</guid>
      <description>Tenet&amp;rsquo;s are 10x shorter and faster to write than Linters Comparison of size in code
   Lines (CL) Lines (L) Words (CL) Words (L) Bytes (CL) Bytes (L) Byte % (CL/L) Tenet name (CL) linter name (L)     18 681 49 2084 524 15616 3.36% unconvert unconvert   19 110 64 275 580 2198 26.39% init gochecknoinits   18 136 67 353 623 2307 27.</description>
    </item>
    
    <item>
      <title>Write You A Haskell</title>
      <link>https://mullikine.github.io/posts/write-you-a-haskell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mullikine.github.io/posts/write-you-a-haskell/</guid>
      <description>This is just a casual writeup of WYAH as I read through it.
 Original article http://dev.stephendiehl.com/fun/ http://dev.stephendiehl.com/fun/002%5Fparsers.html Code https://github.com/sdiehl/write-you-a-haskell  We will build a small functional language called Fun which is a partial Haskell 2010 toy language; complete with:
 a parser type inference datatypes pattern matching desugaring typeclasses higher-kinded types monadic IO arbitrary-rank polymorphism records Core language STG intermediate language lazy evaluation interpreter native code generator a runtime, and several optimization passes.</description>
    </item>
    
  </channel>
</rss>
