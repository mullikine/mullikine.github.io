<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>protocols on Bodacious Blog</title>
    <link>https://mullikine.github.io/tags/protocols/</link>
    <description>Recent content in protocols on Bodacious Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 06 Jun 2020 00:00:00 +1200</lastBuildDate><atom:link href="https://mullikine.github.io/tags/protocols/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>State Synchronization Protocol</title>
      <link>https://mullikine.github.io/posts/state-synchronization-protocol/</link>
      <pubDate>Sat, 06 Jun 2020 00:00:00 +1200</pubDate>
      
      <guid>https://mullikine.github.io/posts/state-synchronization-protocol/</guid>
      <description> Original article Mosh - YouTube Paper https://mosh.org/mosh-paper.pdf  SSP protocol State Synchronization Protocol:
A new secure object synchronization protocol on top of UDP to synchronize abstract state objects in the presence of roaming, intermittent connectivity, and marginal networks.
Transcript from video 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294  thank you very much I&amp;#39;m thrilled to be here today I&amp;#39;m talking about mas which is a new mobile shell it&amp;#39;s like SSH this guy accepted supports roaming it lets you have intermittent connectivity and it it produces a much better user interface so let&amp;#39;s talk about sort of the status quo we&amp;#39;re not going to get into the prehistory but who here has used SSH to connect from one computer to another all right let&amp;#39;s call that everybody so we all know about SSH it uses TCP it connects the two computers together whatever you type at the local terminal gets sent via TCP to the remote host and what are the whatever the application prints comes back to your screen all the user interface comes from the server including whatever you type you have to wait for those packets to go to the network and back just even see what you&amp;#39;re typing so this this was great in based on what&amp;#39;s happened with the internet over the last 17 years which is a lot you can&amp;#39;t roam with SSH if you&amp;#39;re at work and you put your laptop to sleep and you bring it home you don&amp;#39;t have your connection anymore you can&amp;#39;t even roam for one Wi-Fi network to another or from Wi-Fi to cellular yeah an SSH because it runs over TCP responds poorly to packet loss so if you&amp;#39;re on one of these terrible networks like on Amtrak you really can&amp;#39;t expect use SSH we argue that the root cause of this is that this octet stream which SSH sends it&amp;#39;s certainly the wrong layer of abstraction for this kind of application if you&amp;#39;re the client you want to see the latest screen from the application what is the current contents of the screen if you have an interruption in your connectivity for let&amp;#39;s say five seconds you know you really just want to know what should I be looking at now but SSH doesn&amp;#39;t understand what it&amp;#39;s sending so it has to send you everything the application is printed out it could be megabytes just to get you to that current screen state and TCP of course fills up all these Network buffers so then you&amp;#39;re getting all this output from a runaway process in your control C control this is not a new problem I think to anyone here and then it keeps coming and this is just terrible and trying to type you know when you have these huge delays today&amp;#39;s networks it&amp;#39;s not like you know the ARPANET which was you know much faster today we&amp;#39;ve measured with Verizon&amp;#39;s top product therefore G LTE we&amp;#39;ve measured delays of 40 seconds around trip time when you have one TCP download happening so trying to type where you only see what you&amp;#39;re typing forty seconds later that&amp;#39;s that&amp;#39;s terrible so here&amp;#39;s what we built we build two things the first is a new protocol to synchronize not octet streams but objects it&amp;#39;s object synchronization protocol the goal is to have the lowest latency possible in the presence of client roaming you can you can put to sleep for an hour or 10 hours fly to Europe wake it up again you can have a lossy Network path we try and do our best to synchronize abstract objects and number two we use that protocol to build this mobile shell application mush that has a local user interface so when you type you see what you typed immediately so let&amp;#39;s talk about part one the protocol we call it the state synchronization protocol it runs over UDP and it synchronizes the state of abstract objects so the protocol doesn&amp;#39;t have to know the inner details of these objects but the object has to support a simple interface the SSP has to be able to inquire of the object hey here&amp;#39;s the state that I think the receiver has state 3 and I want to get them to state between state 3 and state 9 and that&amp;#39;s just a string and that&amp;#39;s what we convey over the network and object also has to support the universe operation patch to say ok number 3 here&amp;#39;s a patch please mutate yourself to state number 9 so any kind of object that supports that interface can be conveyed over this protocol but it&amp;#39;s we don&amp;#39;t know really the meaning of the object or the meaning of different patch you know whether it&amp;#39;s reliable whether it&amp;#39;s exactly the same or not it&amp;#39;s the objects implementation that ultimately defines the semantics of the protocol not SSP so here&amp;#39;s a diagram of SSH this is the system we all know and have modest affection for there&amp;#39;s the application Emacs on the left it gets conveyed over tcp encrypted tcp to our terminal on the right so we&amp;#39;re going to fill this in here&amp;#39;s SS here&amp;#39;s maj here&amp;#39;s the design of maj so instead we&amp;#39;re just conveying that octet stream we actually represent explicitly in blue here the state that we&amp;#39;re synchronizing we run two copies of s SP two copies of the protocol the version from server to client synchronizes this screen object so we run a terminal emulator at the server that spits out these screen objects and that&amp;#39;s what we synchronize at whatever rate we want and we feed that to the clients terminal emulator like X term and in the reverse direction we just synchronize the keystrokes that you type some of the more minor details it&amp;#39;s protected by the one of these authenticated encryption modes there&amp;#39;s no privilege code an entire project nothing is route you don&amp;#39;t to be route to install it no Damons we use SSH to authenticate you in the first place and this design makes it very easy to roam because we&amp;#39;re not using TCP anymore we&amp;#39;re not bound to IP addresses so roaming becomes trivial the server just says ok what is the latest authentic Datagram that I received from the client the latest one and whatever the source IP address important number of that Datagram is ok that&amp;#39;s my new target I&amp;#39;m going to send all the new packets to so this is the simplest possible way to do roaming it works very well and it means the client doesn&amp;#39;t even have to know that it&amp;#39;s wrong the client could be behind in that and in that roam where that&amp;#39;s still ok we have we tried to do fancy flow control the goal is never fill up a buffer we can skip over States in between that&amp;#39;s ok and we have some tricks that we describe else or to try and balance the robustness of the connection versus the throughput ok now let&amp;#39;s talk about the local user interface so this is the diagram I showed you but actually we going to add one little feature in the upper right loop the predictive local echo so instead of rendering directly the service screen state we mutate a little bit based on what we think is going to appear we have a simple algorithm for this the client runs a predictive model of the users of the cert of the applications behavior the client runs a pretty good model the applications behavior in the background we think when you type it&amp;#39;s probably going to be echoed but we&amp;#39;re not sure because about echoed like in VI you hit I to insert you know that in I never appears on the screen so we try and make these predictions in groups we call epics and the hypothesis is that any epoch is either entirely echoed or not echoed and so we start predicting just in the background if any prediction with an epoch gets confirm then we show the whole epoch and if we make a mistake no big deal we just take away the epoch and if we if the user does something that we don&amp;#39;t know how to handle like it&amp;#39;s the Enter key you know or up and down and that sure it&amp;#39;s gonna happen we just increment the epoch so we keep predicting but it&amp;#39;s in the background so this turns out to work pretty well and I&amp;#39;ll show you a demo here we&amp;#39;re connected back to to my desktop on the top screen we&amp;#39;re typing in mosh and the bottom screen we&amp;#39;re typing in SSH and then just running over the conference Wi-Fi so if the Wi-Fi is good we&amp;#39;re not going to see a big difference so this is a real not rigged demo let&amp;#39;s see here so hello USENIX I am happy to be here ok so that&amp;#39;s basically similar now let&amp;#39;s say you know the conference Wi-Fi is terrible you guys going to help me out there let&amp;#39;s switch over to the Sprint EVDO network so we&amp;#39;re roaming here disconnect it now Maj gives you this helpful error message hey the networks unreachable and then go way-hey you know I haven&amp;#39;t heard for the serve in a while okay everything&amp;#39;s goodness so now it appears we&amp;#39;ve roamed in both terminals mosh everything looks good SSH everything looks good hey let&amp;#39;s let&amp;#39;s keep typing boy am I happy that worked oh my god what&amp;#39;s happening so Maj keeps working SSH is totally dead but it doesn&amp;#39;t even tell us it&amp;#39;s dead that is the most offensive part of SSH so now we have to do this dance we have to kill it and then SSH again this is like I could have graduated by now okay so now this is over the sprint one night let&amp;#39;s put throw in a download here just make it more fun testing what happens when I type on the top with mosh and so you can see if I try and edit type very aggressively on the top whoops so you can see it&amp;#39;s just much more pleasant here and it underlines the show you know hey these haven&amp;#39;t been confirmed by the server yet this is another another test so you just you really couldn&amp;#39;t even expect to use SSH and still enjoy life so that&amp;#39;s the demo we evaluated at the details of evaluation in the paper we found 70% of user keystrokes can be displayed instantly so our media and user interface response is zero it works over lossy links we found that Unicode on UNIX is still full of bugs the details of that are on our website but you can see if you echo the same string to four different terminal emulators you get the circumflex in four different places the Mac OS version has a particular unique interpretation so we put a lot of work into making this a well baked application that you could use it&amp;#39;s distributed with all kinds of versions of Linux and it&amp;#39;s in the Mac the various Mac and FreeBSD ports collections it works sort of on cygwin and Solaris and even less on Android in April someone else posted it before we were ready to all these new sites slash dot vara punto the spanish slash dot 1200 people have signed up to get a notice when we ever fix a bug this is where we immodestly show our admiring tweets we got you know it seems to have struck a nerve with people also we got a rise out of the USENIX reviewers which we enjoyed so people seem to be really using it but we think that you know this is not just about a mobile shell protocol this sort of paradigm of object synchronization we think is appropriate for other applications our program can roam but even very very well funded applications for mobile devices nominally intended for mobility are not mobile Android Gmail Google Chat skyping jingle the website all of these things will break without even disclosing it when you roam that&amp;#39;s just ridiculous this is a snapshot from yesterday from my Android device I sent this email on February 6th or I tried to but as I was looking out of our building the device you know I lost the Wi-Fi signal so it roamed to the cellular connection but because it happened right in the middle of the transfer Gmail got confused and this email still four months later has not been sent so I Jessica&amp;#39;s like wondering where I am if any Google employees in the office you want to come up after the break help me send this email I&amp;#39;d appreciate it but the point the point is that the old way of writing these programs for mobile devices that it doesn&amp;#39;t make the mobile and they should be this is crazy other people should adopt this paradigm we argue so in summary we made SSP a new protocol we made mash which uses it which has become very popular but we argue that this paradigm is probably useful we hope for other applications and should deserve further review we encourage you to visit the web page and I&amp;#39;m honored to have your questions questions Louis Bennett from around here um we&amp;#39;re trying to use this someone has asked for this to be installed on our systems but I&amp;#39;m behind a firewall and I want to know what ports I have to open and what what arguments I&amp;#39;m going to get from Network security which aren&amp;#39;t very friendly to us sure I&amp;#39;m happy to talk to you about that in general you know you have to you have to open as many ports on the machine as you want concurrent connections because that&amp;#39;s how we identify the connection is just by the port number since the IP address can change if you want to allow 10 connections to a machine you have to open 10 ports that&amp;#39;s that&amp;#39;s the story but we&amp;#39;re working on on a better answer that question thank you time for one more what is an analogy for that predictive echo for Gmail is there any like she already has a pretty good local user interface and when you type you do see what you&amp;#39;re typing immediately so I don&amp;#39;t think Gmail is actually as bad as the is the terminal application Thanks ok thank you very much thank you   </description>
    </item>
    
  </channel>
</rss>
