<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>haskell on Bodacious Blog</title>
    <link>https://mullikine.github.io/tags/haskell/</link>
    <description>Recent content in haskell on Bodacious Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Nov 2019 00:00:00 +1300</lastBuildDate>
    
	<atom:link href="https://mullikine.github.io/tags/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Haskell ADTs</title>
      <link>https://mullikine.github.io/posts/haskell-adt/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-adt/</guid>
      <description> ADT of ADT 1 2 3 4 5 6 7 8 9 10 11 12 13 14  data Point = Point Float Float deriving (Show) data Shape = Circle Point Float | Rectangle Point Point deriving (Show) surface :: Shape -&amp;gt; Float surface (Circle _ r) = pi * r ^ 2 surface (Rectangle (Point x1 y1) (Point x2 y2)) = (abs $ x2 - x1) * (abs $ y2 - y1) :info Point :info Circle :t Point :t Circle surface $ Circle (Point 10 20) 10 surface $ Rectangle (Point 0 0) (Point 100 100)   </description>
    </item>
    
    <item>
      <title>Haskell and emacs</title>
      <link>https://mullikine.github.io/posts/haskell-emacs/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-emacs/</guid>
      <description> Run haskell programs: babel + runhaskell 1 2 3 4 5 6 7  main = do putStrLn &amp;#34;What is your name?&amp;#34; name &amp;lt;- getLine putStrLn $ name ++ &amp;#34;! This is a very nice name.&amp;#34; putStrLn &amp;#34;Where do you live?&amp;#34; city &amp;lt;- getLine putStrLn $ &amp;#34;Hey, I Love &amp;#34; ++ city ++ &amp;#34;!&amp;#34;   </description>
    </item>
    
    <item>
      <title>Haskell syntax</title>
      <link>https://mullikine.github.io/posts/haskell-syntax/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-syntax/</guid>
      <description>let expression 1  (let x = 2 in x*2)   4 import ... hiding 1  ewwlinks +/&amp;#34;Haskell Language Hiding Imports&amp;#34; &amp;#34;https://riptutorial.com/haskell/example/18580/hiding-imports&amp;#34;   1  egr haskell import hiding   Prelude often defines functions whose names are used elsewhere. Not hiding such imports (or using qualified imports where clashes occur) will cause compilation errors.
Data.Stream defines functions named map, head and tail which normally clashes with those defined in Prelude.</description>
    </item>
    
    <item>
      <title>Haskell typeclasses</title>
      <link>https://mullikine.github.io/posts/haskelll-typeclasses/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskelll-typeclasses/</guid>
      <description>Functor 1  ghciol &amp;#39;:info Functor&amp;#39;   class Functor (f :: * -&amp;gt; *) where fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b (&amp;lt;$) :: a -&amp;gt; f b -&amp;gt; f a {-# MINIMAL fmap #-} -- Defined in ‘GHC.Base’ instance Functor (Either a) -- Defined in ‘Data.Either’ instance Functor [] -- Defined in ‘GHC.Base’ instance Functor Maybe -- Defined in ‘GHC.Base’ instance Functor IO -- Defined in ‘GHC.</description>
    </item>
    
    <item>
      <title>Misc LYAH notes</title>
      <link>https://mullikine.github.io/posts/haskell-lyah/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-lyah/</guid>
      <description> list where 1 2 3  [ x | x &amp;lt;- [50..100], x `mod` 7 == 3] [x*2 | x &amp;lt;- [1..10]] [x*2 | x &amp;lt;- [1..10], x*2 &amp;gt;= 12]   [2,4,6,8,10,12,14,16,18,20] [12,14,16,18,20] take cycle 1  take 12 (cycle &amp;#34;LOL &amp;#34;)   &amp;#34;LOL LOL LOL &amp;#34; texas range 1  [&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;]   &amp;#34;abcdefghijklmnopqrstuvwxyz&amp;#34; Type of Nothing 1  :t Nothing   Nothing :: Maybe a 1  :t Nothing   Nothing :: Maybe a</description>
    </item>
    
    <item>
      <title>GHCi and Haskell code intermixed in babel</title>
      <link>https://mullikine.github.io/posts/babel-ghci-and-haskell/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/babel-ghci-and-haskell/</guid>
      <description>Demonstration Running ghcih inside neovim inside emacs 
Create the ghcih script 1 2 3 4 5 6  #!/bin/bash export TTY ( hs &amp;#34;$(basename &amp;#34;$0&amp;#34;)&amp;#34; &amp;#34;$@&amp;#34; &amp;#34;#&amp;#34; &amp;#34;&amp;lt;==&amp;#34; &amp;#34;$(ps -o comm= $PPID)&amp;#34; 0&amp;lt;/dev/null ) &amp;amp;&amp;gt;/dev/null xs ghci -H &amp;#34;$@&amp;#34;   Create the ghci case in xs When -H is provided, it will split the input code by assuming that the initial part is a haskell module and anything from the first ghci : command and onwards is ghci code.</description>
    </item>
    
    <item>
      <title>Notes on JSON Parser From Scratch in Haskell</title>
      <link>https://mullikine.github.io/posts/json-parser-haskell/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/json-parser-haskell/</guid>
      <description>Original video JSON Parser From Scratch in Haskell  Concepts taught    Concept     hole   newtype   Traversable   Functor   Applicative   Alternative   Record syntax    Glossary 1 2 3 4 5 6 7 8 9 10 11  type vs data vs newtype The &amp;#39;data&amp;#39; keyword allows you to introduce a new algebraic data type, while &amp;#39;type&amp;#39; just makes a type synonym.</description>
    </item>
    
    <item>
      <title>Interactively loading GHCi commands</title>
      <link>https://mullikine.github.io/posts/interactively-loading-ghci-commands/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/interactively-loading-ghci-commands/</guid>
      <description>I&amp;rsquo;d like to be able to load commands into ghci and have the commands verbosely printed.
Likely you have a lot of .ghci files 1  locate .ghci   Case in point This file is actually a .ghci file as it contains commands such as :t (&amp;gt;)
https://github.com/bishboria/learnyouahaskell/blob/master/02/2%5Ftypes.hs
I created an expect script for this purpose using my expect-generation script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  hs|ghci) { cmd=&amp;#34;$1&amp;#34; shift if stdin_exists; then tfin=&amp;#34;$(cat | tf txt)&amp;#34; inpara=&amp;#34;-sf $(aqf &amp;#34;$tfin&amp;#34;)&amp;#34; else : ${cmd:=&amp;#34;foldl (/) 64 [4,2,4]&amp;#34;} fi # x -cd &amp;#34;$(pwd)&amp;#34; -sh &amp;#34;ghci&amp;#34; -r &amp;#34;^.</description>
    </item>
    
    <item>
      <title>Haskell modes for emacs</title>
      <link>https://mullikine.github.io/posts/haskell-modes-for-emacs/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-modes-for-emacs/</guid>
      <description>This post is to help me keep track of all the garbage emacs modes floating around for Haskell.
Tooling is a huge deficiency with haskell, not just for emacs.
   mode pros cons     lsp-mode looks pretty keeps asking for project root. does not remember   flymake  leaves garbage files lying around in project directory   intero reliable, pretty type inference slow   haskell-mode reliable very basic; lacking    </description>
    </item>
    
    <item>
      <title>Haskell troubleshooting</title>
      <link>https://mullikine.github.io/posts/haskell-troubleshooting/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-troubleshooting/</guid>
      <description>Can&amp;rsquo;t find module which exists and is in the same directory  source code https://github.com/ThomasZumsteg/exercism-haskell/blob/master/say/say%5Ftest.hs  Asked on #haskell 1 2 3 4 5 6  16:19 &amp;lt; libertyprime&amp;gt; having trouble getting this to run https://asciinema.org/a/Z7G0B7ZmNtwjcnSSylEAWpUaI https://github.com/ThomasZumsteg/exercism-haskell/blob/master/say/say_test.hs 16:19 &amp;lt; libertyprime&amp;gt; not sure why 16:19 &amp;lt; libertyprime&amp;gt; the module is defined in say.hs in the same directory as say_test.hs 16:20 &amp;lt; Axman6&amp;gt; you probably want Say.hs 16:20 ::: Join to #haskell was synced in 378 secs 16:23 &amp;lt; libertyprime&amp;gt; thanks axman.</description>
    </item>
    
    <item>
      <title>(WIP) Syntax transformers step by step</title>
      <link>https://mullikine.github.io/posts/monad-transformers-step-by-step/</link>
      <pubDate>Fri, 25 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/monad-transformers-step-by-step/</guid>
      <description>Demonstrate monad transformers Build an interpreter for the little language below. type Name = String -- variable names data Exp = Lit Integer -- expressions | Var Name | Plus Exp Exp | Abs Name Exp | App Exp Exp deriving (Show) data Value = IntVal Integer -- values | FunVal Env Name Exp deriving (Show) type Env = Map.Map Name Value -- mapping from names to values Add the header module Transformers where import Control.</description>
    </item>
    
    <item>
      <title>Haskell development 20.10.19</title>
      <link>https://mullikine.github.io/posts/haskell-development/</link>
      <pubDate>Sun, 20 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-development/</guid>
      <description>Original file $NOTES/ws/playgrounds/haskell/remember.org  This works now 1 2  echo :t 5 | ghciol ghciol :t 4   5 :: Num p =&amp;gt; p 4 :: Num p =&amp;gt; p ghci 1 2 3 4 5 6  Just &amp;#34;Haha&amp;#34; Just 84 :t Just &amp;#34;Haha&amp;#34; :t Just 84 :t Nothing Just 10 :: Maybe Double   Why is it that if something is a monad, you can use do notation with it?</description>
    </item>
    
    <item>
      <title>Alternative preludes for Haskell</title>
      <link>https://mullikine.github.io/posts/alternative-preludes-for-haskell/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/alternative-preludes-for-haskell/</guid>
      <description>Glossary Lazy IO haskell
Foundation Provide a better and more efficient prelude than base&amp;rsquo;s prelude.
https://hackage.haskell.org/package/foundation
be self-sufficient: no external dependencies apart from base.
provide better data-types: packed unicode string by default, arrays.
Better numerical classes that better represent mathematical thing (No more all-in-one Num).
Better I/O system with less Lazy IO
Usual partial functions distinguished through type system
Lazy IO https://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o
Lazy IO has the problem that releasing whatever resource you have acquired is somewhat unpredictable, as it depends on how your program consumes the data &amp;ndash; its &amp;ldquo;demand pattern&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Blogs and Vlogs</title>
      <link>https://mullikine.github.io/posts/blogs-and-vlogs/</link>
      <pubDate>Mon, 14 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/blogs-and-vlogs/</guid>
      <description>These are some of my favourite learning resources.
   source type url Topics     Math4IQB vlog https://www.youtube.com/user/Math4IQB/videos Information Theory   Gwern Bransen blog https://www.gwern.net/GPT-2 Haskell, NLP, R   Fabian Dablander blog https://fabiandablander.com Math, statistics, latex   John D. Cook blog https://www.johndcook.com/blog/ Math, statistics   Sacha Chua blog https://sachachua.com/blog/0000/00/05/ New emacs packages   Cameron Kerr blog http://humbledown.org https://distracted-it.blogspot.com Telecommunications    Misc articles Math &amp;amp; Statistics johndcook.</description>
    </item>
    
    <item>
      <title>Fused effects</title>
      <link>https://mullikine.github.io/posts/fused-effects/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +1200</pubDate>
      
      <guid>https://mullikine.github.io/posts/fused-effects/</guid>
      <description>Original video &amp;ldquo;Building Haskell Programs with Fused Effects&amp;rdquo; by Patrick Thomson - YouTube  Part of the GitHub semantic code team.
Install fused-effects stack install fused-effects Slides fused-effects is  a library for building Haskell programs an effect system providing fused, scoped, higher-order algebraic effects. performant, production-quality software suitable for industrial use.  Today, we&amp;rsquo;ll&amp;hellip;  describe the status quo of building Haskell programs explore how this status quo can be limiting show how fused-effects can overcome these limitations pinpoint fused-effects&amp;rsquo;s position in the design space  How are we to build programs in Haskell?</description>
    </item>
    
    <item>
      <title>Learning Haskell</title>
      <link>https://mullikine.github.io/posts/learning-haskell/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +1200</pubDate>
      
      <guid>https://mullikine.github.io/posts/learning-haskell/</guid>
      <description>Start with haskellbook.com and avoid learn you a haskell according to Tsoding.
My Haskell Setup - YouTube
Useful tools stack install hindent stack install hlint stack install repline stack install hasktags stack install importify hlint Apparently this is all you need to learn haskell.
Reading Monad transformers step-by-step https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf $DUMP$NOTES/ws/haskell/reading/monad-transformers-step-by-step.txt
Module Data.Maybe Defines useful functions for dealing with optional values of type Maybe a.
Module Data.Map Defines finite maps.</description>
    </item>
    
    <item>
      <title>Haskell functions</title>
      <link>https://mullikine.github.io/posts/haskell-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-functions/</guid>
      <description>name a lambda expression (if you wanted to for some reason) 1  addOne = \x -&amp;gt; x + 1   LYAH modules http://learnyouahaskell.com/modules
intersperse Takes an element and a list and then puts that element in between each pair of elements in the list.
1 2 3  :m Data.List intersperse &amp;#39;.&amp;#39; &amp;#34;MONKEY&amp;#34; intersperse 0 [1,2,3,4,5,6]   &amp;#34;M.O.N.K.E.Y&amp;#34; [1,0,2,0,3,0,4,0,5,0,6] intercalate Takes a list of lists and a list.</description>
    </item>
    
  </channel>
</rss>