<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>haskell on Bodacious Blog</title>
    <link>https://mullikine.github.io/tags/haskell/</link>
    <description>Recent content in haskell on Bodacious Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 May 2020 00:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://mullikine.github.io/tags/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>An exposition of racket languages</title>
      <link>https://mullikine.github.io/posts/an-exposition-of-racket-languages/</link>
      <pubDate>Sat, 30 May 2020 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/an-exposition-of-racket-languages/</guid>
      <description>Firstly, add to emacs a way of selecting the racket language  Languages to add:  racket rackjure hackett sicp rash    Emacs lisp code 1  (&amp;#34;L&amp;#34; (hot-expand &amp;#34;&amp;lt;s&amp;#34; &amp;#34;racket-sublang&amp;#34;) &amp;#34;racket&amp;#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  (defun hot-expand (str &amp;amp;optional mod header) &amp;#34;Expand org template. STR is a structure template string recognised by org like &amp;lt;s.</description>
    </item>
    
    <item>
      <title>Future of applied haskell</title>
      <link>https://mullikine.github.io/posts/future-of-applied-haskell/</link>
      <pubDate>Sat, 25 Jan 2020 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/future-of-applied-haskell/</guid>
      <description>Reading material http://www.stephendiehl.com/posts/decade.html  Algebraic Effect Systems   Current, old system:
 mtl Monad Transformer Library    Potential replacements systems: \
These effect-system libraries may help to achieve a boilerplate-free nirvana of tracking algebraic effects at much more granular levels.
 fused-effects polysemy eff screaming fast extensible effects for less    https://github.com/hasura/eff</description>
    </item>
    
    <item>
      <title>Review of &#39;Counting inversions via rank queries | blog :: Brent -&gt; [String]&#39;</title>
      <link>https://mullikine.github.io/posts/review-of-counting-inversions-via-rank-queries-blog-brent-string/</link>
      <pubDate>Sat, 04 Jan 2020 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/review-of-counting-inversions-via-rank-queries-blog-brent-string/</guid>
      <description>Original article Counting inversions via rank queries | blog :: Brent -&amp;gt; String   Count the number of inversions of a sequence in \(O(n \lg n)\)  inversion Given a sequence \(a_1, a_2, \dots, a_n\) , an inversion is a pair of positions \(i, j\) such that \(a_i\) and \(a_j\) are in the “wrong order”, that is, \(i &amp;lt; j\) but \(a_i &amp;gt; a_j\) .  There can be up to \(n(n-1)/2\) inversions in the worst case, so we cannot hope to count them in faster than quadratic time by simply incrementing a counter.</description>
    </item>
    
    <item>
      <title>Review of emacs distributions</title>
      <link>https://mullikine.github.io/posts/emacs-distributions/</link>
      <pubDate>Sat, 04 Jan 2020 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/emacs-distributions/</guid>
      <description>All the distributions I use are overlaid with my own customisations to make them very similar to each other by making my own key bindings and hydras layer. They still retain their own peculiarities, but I have taken a decent portion of code from each distribution to form a common functionality layer.
I have over 1300 emacs plugins which all distributions share.
Spacemacs  Very good default keybindings. Great support for LSP.</description>
    </item>
    
    <item>
      <title>Reading 23.12.19</title>
      <link>https://mullikine.github.io/posts/reading-23.12.19/</link>
      <pubDate>Mon, 23 Dec 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/reading-23.12.19/</guid>
      <description>AI NLP  Language Engineering; Harnessing the Power of Language Google AI Blog: ALBERT: A Lite BERT for Self-Supervised Learning of Language Representations  Computer Vision  ObjectNet  Automated testing  Cucumber | Tools &amp;amp; techniques that elevate teams to greatness Writing Features - Gherkin Language - Behat 2.5.3 documentation  Information Retrieval  Why databases use ordered indexes but programming uses hash tables (evanjones.ca)  Programming languages haskell parsers  An introduction to parsing text in Haskell with Parsec - Nick.</description>
    </item>
    
    <item>
      <title>Parsing with parsec</title>
      <link>https://mullikine.github.io/posts/parsing-with-parsec/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/parsing-with-parsec/</guid>
      <description> Source material Parsing using Parsec: a practical example [ CODE ] An introduction to parsing text in Haskell with Parsec - Nick.Chung - - [ CODE ] parsec: Monadic parser combinators Parsec - HaskellWiki  </description>
    </item>
    
    <item>
      <title>Finding similar haskell functions from emacs and downloading their packages: Hoogle, intero, fzf</title>
      <link>https://mullikine.github.io/posts/hoogle-fuzzy-type-search-from-intero-emacs/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/hoogle-fuzzy-type-search-from-intero-emacs/</guid>
      <description>Demonstration 
Make these functions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  (defun my-intero-get-type () (interactive) (my-enable-intero) (let ((out (sh-notty &amp;#34;sed -z -e \&amp;#34;s/\\n/ /g\&amp;#34; -e \&amp;#34;s/ \\+/ /g\&amp;#34;&amp;#34; (sed &amp;#34;s/^[^:]\\+ :: //&amp;#34; (intero-get-type-at (beginning-of-thing &amp;#39;sexp) (end-of-thing &amp;#39;sexp)))))) (if (called-interactively-p &amp;#39;any) (my/copy out) out))) (defun hs-download-packages-with-function-type (type) (interactive (list (my-intero-get-type))) ;; (term-nsfa &amp;#34;hsqf pg&amp;#34;) ;; (e/sph-zsh &amp;#34;t new \&amp;#34;rtcmd hs-type-declarative-search-fzf String\&amp;#34;&amp;#34;) (sph (concat &amp;#34;t new &amp;#34; (q &amp;#34;hs-download-packages-with-function-type &amp;#34; (q type))))) (defun hs-tds-fzf (type) (interactive (list (my-intero-get-type))) ;; (term-nsfa &amp;#34;hsqf pg&amp;#34;) ;; (e/sph-zsh &amp;#34;t new \&amp;#34;rtcmd hs-type-declarative-search-fzf String\&amp;#34;&amp;#34;) (sph (concat &amp;#34;t new &amp;#34; (q &amp;#34;rtcmd hs-type-declarative-search-fzf &amp;#34; (q type))))) (defun my/type-search-thing-at-point (&amp;amp;optional immediate winfunc) &amp;#34;Show doc for thing under pointl.</description>
    </item>
    
    <item>
      <title>Exploring Hoogle</title>
      <link>https://mullikine.github.io/posts/exploring-hoogle/</link>
      <pubDate>Sat, 30 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/exploring-hoogle/</guid>
      <description>Prereading Real-time interactive documentation lookup for haskell type-declarative search // Bodacious Blog GHCi and Haskell code intermixed in babel // Bodacious Blog  Finding package from the module name / an import statement Demonstration 
I created these two functions 1 2 3 4 5 6 7 8 9  hsImportToPackage :: String -&amp;gt; IO String hsImportToPackage modulename = do (_, Just hout, _, _) &amp;lt;- createProcess (proc &amp;#34;hs-import-to-package&amp;#34; [modulename]){ std_out = CreatePipe } hGetContents hout printIOString :: IO String -&amp;gt; IO () printIOString a = do str &amp;lt;- a putStrLn str   1  ghciol &amp;#34;:i fmap&amp;#34;   class Functor (f :: * -&amp;gt; *) where fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b .</description>
    </item>
    
    <item>
      <title>introhaskell</title>
      <link>https://mullikine.github.io/posts/introhaskell/</link>
      <pubDate>Fri, 29 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/introhaskell/</guid>
      <description>Original article introhaskell  Glossary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  type variable Example: Given the type: a -&amp;gt; a -&amp;gt; a &amp;#39;a&amp;#39; is a type variable. ewwlinks +/&amp;#34;Type Variables&amp;#34; &amp;#34;https://cs.lmu.edu/~ray/notes/introhaskell/&amp;#34; We know [Char] and [Float] are two different types. So how do we speak about, or write functions that work on, lists of ANY type? Or tuples of any size, or any component type?</description>
    </item>
    
    <item>
      <title>More haskell syntax and babel improvements. Notes 29.11.19</title>
      <link>https://mullikine.github.io/posts/haskell-notes-29.11.19/</link>
      <pubDate>Fri, 29 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-notes-29.11.19/</guid>
      <description>stdin in babel. I can now do literate programming with pipeline scripts 1 2  #+BEGIN_SRC haskell-n :stdin &amp;#34;echo &amp;#39;h/*sup*/i&amp;#39;&amp;#34; :interpreter runhaskell :async :results verbatim code #+END_SRC   Changes made to babel. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  diff --git a/config/my-babel.</description>
    </item>
    
    <item>
      <title>Monad transformers</title>
      <link>https://mullikine.github.io/posts/monad-transformers/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/monad-transformers/</guid>
      <description>Original resource https://wiki.haskell.org/Meta-tutorial  grok haskell monad transformers  Original article http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html  State monad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  import Control.Monad.Identity import Control.Monad.State test1 = do a &amp;lt;- get modify (+1) b &amp;lt;- get return (a,b) test2 = do a &amp;lt;- get modify (++&amp;#34;1&amp;#34;) b &amp;lt;- get return (a,b) go1 = evalState test1 0 go2 = evalState test2 &amp;#34;0&amp;#34; :t go1 go1 :t go2 go2 &amp;#34;**************&amp;#34; :t get :i get &amp;#34;**************&amp;#34; :t modify :i modify &amp;#34;**************&amp;#34; :t evalState :i evalState   go1 :: (Integer, Integer) (0,1) go2 :: ([Char], [Char]) (&amp;#34;0&amp;#34;,&amp;#34;01&amp;#34;) &amp;#34;**************&amp;#34; get :: MonadState s m =&amp;gt; m s class Monad m =&amp;gt; MonadState s (m :: * -&amp;gt; *) | m -&amp;gt; s where get :: m s .</description>
    </item>
    
    <item>
      <title>Real-time interactive documentation lookup for haskell type-declarative search</title>
      <link>https://mullikine.github.io/posts/doc-lookup-for-haskell-type-declarative-search/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/doc-lookup-for-haskell-type-declarative-search/</guid>
      <description>I make a tool for real-time fuzzy documentation lookup for haskell type- declarative search.
Demonstration; the final result 
Create the script hs-type-declarative-search This uses stack.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65  #!</description>
    </item>
    
    <item>
      <title>ClassyPrelude – Alternative prelude for Haskell</title>
      <link>https://mullikine.github.io/posts/haskell-classy-prelude/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-classy-prelude/</guid>
      <description>Sources https://hackage.haskell.org/package/classy-prelude  New stuff  Text  Lots of things use Text instead of String. Note that show returns a String. To get back Text, use tshow.   other functionality  exceptions package system-filepath convenience functions whenM, unlessM hashNub and ordNub (efficient nub implementations).    Automate ClassyPrelude ghci repl extend the ghci-alternative-prelude script. Symlink as classy-prelude 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  #!</description>
    </item>
    
    <item>
      <title>Haskell functions</title>
      <link>https://mullikine.github.io/posts/haskell-functions/</link>
      <pubDate>Wed, 27 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-functions/</guid>
      <description>name a lambda expression (if you wanted to for some reason) 1  addOne = \x -&amp;gt; x + 1   LYAH modules http://learnyouahaskell.com/modules
intersperse Takes an element and a list and then puts that element in between each pair of elements in the list.
1 2 3  :m Data.List intersperse &amp;#39;.&amp;#39; &amp;#34;MONKEY&amp;#34; intersperse 0 [1,2,3,4,5,6]   &amp;#34;M.O.N.K.E.Y&amp;#34; [1,0,2,0,3,0,4,0,5,0,6] intercalate Takes a list of lists and a list.</description>
    </item>
    
    <item>
      <title>GHCi and Haskell code intermixed in babel</title>
      <link>https://mullikine.github.io/posts/babel-ghci-and-haskell/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/babel-ghci-and-haskell/</guid>
      <description>Demonstration Running ghcih inside neovim inside emacs 
Create the ghcih script 1 2 3 4 5 6  #!/bin/bash export TTY ( hs &amp;#34;$(basename &amp;#34;$0&amp;#34;)&amp;#34; &amp;#34;$@&amp;#34; &amp;#34;#&amp;#34; &amp;#34;&amp;lt;==&amp;#34; &amp;#34;$(ps -o comm= $PPID)&amp;#34; 0&amp;lt;/dev/null ) &amp;amp;&amp;gt;/dev/null xs ghci -H &amp;#34;$@&amp;#34;   Create the ghci case in xs When -H is provided, it will split the input code by assuming that the initial part is a haskell module and anything from the first ghci : command and onwards is ghci code.</description>
    </item>
    
    <item>
      <title>Relude – Alternative prelude for Haskell</title>
      <link>https://mullikine.github.io/posts/haskell-relude/</link>
      <pubDate>Tue, 26 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-relude/</guid>
      <description>Sources https://hackage.haskell.org/package/relude  Difference from Prelude Main differences from Prelude can be grouped into the following categories:
 Changed behavior of common functions  head, tail, last, init work with NonEmpty a instead of [a]. lines, unlines, words, unwords work with Text instead of String. show is polymorphic over return type. Functions sum and product are strict now, which makes them more efficient. You can&amp;rsquo;t call elem and notElem functions over Set and HashSet.</description>
    </item>
    
    <item>
      <title>Deconstructing IPTables-Metalanguage</title>
      <link>https://mullikine.github.io/posts/deconstructing-iptables-metalanguage/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/deconstructing-iptables-metalanguage/</guid>
      <description>Main.hs 1 2 3 4 5 6 7  ./Main.hs:4:import Test.Framework (defaultMain, testGroup) ./Main.hs:6:import Test.Framework.Providers.QuickCheck2 (testProperty) ./Main.hs:11:import Text.ParserCombinators.Parsec ./Main.hs:13:import Text.IptablesMetalanguage.Types ./Main.hs:14:import Text.IptablesMetalanguage.Parser ./Main.hs:15:import Text.IptablesMetalanguage.Print ./Main.hs:17:import GHC.Word   Test.Framework http://hackage.haskell.org/package/HTF
Tutorial http://hackage.haskell.org/package/HTF-0.14.0.0/docs/Test-Framework-Tutorial.html
defaultMain testGroup Parser.hs 1 2 3 4 5 6 7 8  ./src/Text/IptablesMetalanguage/Parser.hs:4:import Text.IptablesMetalanguage.Types ./src/Text/IptablesMetalanguage/Parser.hs:5:import Control.Applicative ((&amp;lt;$&amp;gt;)) ./src/Text/IptablesMetalanguage/Parser.hs:6:import Control.Monad.Error ./src/Text/IptablesMetalanguage/Parser.hs:7:import Data.Bits ./src/Text/IptablesMetalanguage/Parser.hs:8:import Data.Set (fromList) ./src/Text/IptablesMetalanguage/Parser.hs:9:import Data.Word ./src/Text/IptablesMetalanguage/Parser.hs:10:import Safe ./src/Text/IptablesMetalanguage/Parser.hs:11:import Text.ParserCombinators.Parsec   Types.hs 1 2  ./src/Text/IptablesMetalanguage/Types.hs:4:import Data.Set .</description>
    </item>
    
    <item>
      <title>Notes on JSON Parser From Scratch in Haskell</title>
      <link>https://mullikine.github.io/posts/json-parser-haskell/</link>
      <pubDate>Mon, 25 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/json-parser-haskell/</guid>
      <description>Original video JSON Parser From Scratch in Haskell  Concepts taught    Concept     hole   newtype   Traversable   Functor   Applicative   Alternative   Record syntax    Glossary 1 2 3 4 5 6 7 8 9 10 11  type vs data vs newtype The &amp;#39;data&amp;#39; keyword allows you to introduce a new algebraic data type, while &amp;#39;type&amp;#39; just makes a type synonym.</description>
    </item>
    
    <item>
      <title>Overview of the semantic parser</title>
      <link>https://mullikine.github.io/posts/adding-new-languages-to-semantic/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/adding-new-languages-to-semantic/</guid>
      <description>Glossary 1 2 3 4 5 6 7  expression problem The goal is to define a datatype by cases, where one can add new cases to the datatype and new functions over the datatype, without recompiling existing code, and while retaining static type safety (e.g., no casts).   Adding new languages to Semantic  Original article https://github.com/github/semantic/blob/master/docs/adding-new-languages.md  Adding new languages and syntax requires no changes to existing code.</description>
    </item>
    
    <item>
      <title>Interactively loading GHCi commands</title>
      <link>https://mullikine.github.io/posts/interactively-loading-ghci-commands/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/interactively-loading-ghci-commands/</guid>
      <description>I&amp;rsquo;d like to be able to load commands into ghci and have the commands verbosely printed.
Likely you have a lot of .ghci files 1  locate .ghci   Case in point This file is actually a .ghci file as it contains commands such as :t (&amp;gt;)
https://github.com/bishboria/learnyouahaskell/blob/master/02/2%5Ftypes.hs
I created an expect script for this purpose using my expect-generation script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  hs|ghci) { cmd=&amp;#34;$1&amp;#34; shift if stdin_exists; then tfin=&amp;#34;$(cat | tf txt)&amp;#34; inpara=&amp;#34;-sf $(aqf &amp;#34;$tfin&amp;#34;)&amp;#34; else : ${cmd:=&amp;#34;foldl (/) 64 [4,2,4]&amp;#34;} fi # x -cd &amp;#34;$(pwd)&amp;#34; -sh &amp;#34;ghci&amp;#34; -r &amp;#34;^.</description>
    </item>
    
    <item>
      <title>Haskell modes for emacs</title>
      <link>https://mullikine.github.io/posts/haskell-modes-for-emacs/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-modes-for-emacs/</guid>
      <description>This post is to help me keep track of all the garbage emacs modes floating around for Haskell.
Tooling is a huge deficiency with haskell, not just for emacs.
   mode pros cons     lsp-mode looks pretty keeps asking for project root. does not remember   flymake  leaves garbage files lying around in project directory   intero reliable, pretty type inference slow   haskell-mode reliable very basic; lacking    </description>
    </item>
    
    <item>
      <title>Haskell troubleshooting</title>
      <link>https://mullikine.github.io/posts/haskell-troubleshooting/</link>
      <pubDate>Wed, 30 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-troubleshooting/</guid>
      <description>Can&amp;rsquo;t find module which exists and is in the same directory  source code https://github.com/ThomasZumsteg/exercism-haskell/blob/master/say/say%5Ftest.hs  Asked on #haskell 1 2 3 4 5 6  16:19 &amp;lt; libertyprime&amp;gt; having trouble getting this to run https://asciinema.org/a/Z7G0B7ZmNtwjcnSSylEAWpUaI https://github.com/ThomasZumsteg/exercism-haskell/blob/master/say/say_test.hs 16:19 &amp;lt; libertyprime&amp;gt; not sure why 16:19 &amp;lt; libertyprime&amp;gt; the module is defined in say.hs in the same directory as say_test.hs 16:20 &amp;lt; Axman6&amp;gt; you probably want Say.hs 16:20 ::: Join to #haskell was synced in 378 secs 16:23 &amp;lt; libertyprime&amp;gt; thanks axman.</description>
    </item>
    
    <item>
      <title>Haskell development 20.10.19</title>
      <link>https://mullikine.github.io/posts/haskell-development/</link>
      <pubDate>Sun, 20 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-development/</guid>
      <description>Original file $NOTES/ws/playgrounds/haskell/remember.org  This works now 1 2  echo :t 5 | ghciol ghciol :t 4   5 :: Num p =&amp;gt; p 4 :: Num p =&amp;gt; p ghci 1 2 3 4 5 6  Just &amp;#34;Haha&amp;#34; Just 84 :t Just &amp;#34;Haha&amp;#34; :t Just 84 :t Nothing Just 10 :: Maybe Double   Why is it that if something is a monad, you can use do notation with it?</description>
    </item>
    
    <item>
      <title>Alternative preludes for Haskell</title>
      <link>https://mullikine.github.io/posts/alternative-preludes-for-haskell/</link>
      <pubDate>Thu, 17 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/alternative-preludes-for-haskell/</guid>
      <description>Related reading https://guide.aelve.com/haskell/alternative-preludes-zr69k1hc  Glossary Lazy IO haskell
Foundation Provide a better and more efficient prelude than base&amp;rsquo;s prelude.
https://hackage.haskell.org/package/foundation
be self-sufficient: no external dependencies apart from base.
provide better data-types: packed unicode string by default, arrays.
Better numerical classes that better represent mathematical thing (No more all-in-one Num).
Better I/O system with less Lazy IO
Usual partial functions distinguished through type system
Lazy IO https://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o
Lazy IO has the problem that releasing whatever resource you have acquired is somewhat unpredictable, as it depends on how your program consumes the data &amp;ndash; its &amp;ldquo;demand pattern&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Blogs and Vlogs</title>
      <link>https://mullikine.github.io/posts/blogs-and-vlogs/</link>
      <pubDate>Mon, 14 Oct 2019 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/blogs-and-vlogs/</guid>
      <description>Blogs and vlogs These people have been influential to me.
2019    source type url Topics     Math4IQB vlog Math4IQB - YouTube Information Theory   Gwern Bransen blog GPT-2 Neural Network Poetry Gwern.net Haskell, NLP, R   Fabian Dablander blog Fabian Dablander - PhD Student Methods Statistics Math, statistics, latex   John Kitchen blog The Kitchin Research Group Emacs   John D.</description>
    </item>
    
    <item>
      <title>Misc LYAH notes</title>
      <link>https://mullikine.github.io/posts/haskell-lyah/</link>
      <pubDate>Thu, 10 Oct 2019 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-lyah/</guid>
      <description>Related articles Haskell functions // Bodacious Blog  emacs Run haskell programs: babel + runhaskell 1 2 3 4 5 6 7 8 9  #+BEGIN_SRC haskell-n :sph nvc -pak rh :async :results none  main = do putStrLn &amp;#34;What is your name?&amp;#34; name &amp;lt;- getLine putStrLn $ name ++ &amp;#34;! This is a very nice name.&amp;#34; putStrLn &amp;#34;Where do you live?&amp;#34; city &amp;lt;- getLine putStrLn $ &amp;#34;Hey, I Love &amp;#34; ++ city ++ &amp;#34;!</description>
    </item>
    
    <item>
      <title>Fused effects</title>
      <link>https://mullikine.github.io/posts/fused-effects/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +1200</pubDate>
      
      <guid>https://mullikine.github.io/posts/fused-effects/</guid>
      <description>Original video &amp;ldquo;Building Haskell Programs with Fused Effects&amp;rdquo; by Patrick Thomson - YouTube  Part of the GitHub semantic code team.
Install fused-effects stack install fused-effects Slides fused-effects is  a library for building Haskell programs an effect system providing fused, scoped, higher-order algebraic effects. performant, production-quality software suitable for industrial use.  Today, we&amp;rsquo;ll&amp;hellip;  describe the status quo of building Haskell programs explore how this status quo can be limiting show how fused-effects can overcome these limitations pinpoint fused-effects&amp;rsquo;s position in the design space  How are we to build programs in Haskell?</description>
    </item>
    
    <item>
      <title>Learning Haskell</title>
      <link>https://mullikine.github.io/posts/learning-haskell/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +1200</pubDate>
      
      <guid>https://mullikine.github.io/posts/learning-haskell/</guid>
      <description>Start with haskellbook.com and avoid learn you a haskell according to Tsoding.
My Haskell Setup - YouTube
Useful tools stack install hindent stack install hlint stack install repline stack install hasktags stack install importify hlint Apparently this is all you need to learn haskell.
Reading Monad transformers step-by-step https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf $DUMP$NOTES/ws/haskell/reading/monad-transformers-step-by-step.txt
Module Data.Maybe Defines useful functions for dealing with optional values of type Maybe a.
Module Data.Map Defines finite maps.
Basic monads https://wiki.</description>
    </item>
    
    <item>
      <title>Haskell at Facebook</title>
      <link>https://mullikine.github.io/posts/haskell-at-facebook/</link>
      <pubDate>Tue, 30 Apr 2019 00:00:00 +0800</pubDate>
      
      <guid>https://mullikine.github.io/posts/haskell-at-facebook/</guid>
      <description>Glossary 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  FXL Feature eXtraction Language DEPRECATED. Used before 2015. Scrapped. Used in combatting spam on the social networking service. FXL described as a narrowly-optimized implementation of a well-chosen subset of Standard ML (with some customized syntax). FXL offers two key advantages: it is simple and easy to write, yet extremely efficient for Facebook-sized workloads.</description>
    </item>
    
  </channel>
</rss>