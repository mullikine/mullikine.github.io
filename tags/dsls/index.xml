<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dsls on Bodacious Blog</title>
    <link>https://mullikine.github.io/tags/dsls/</link>
    <description>Recent content in dsls on Bodacious Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Nov 2020 00:00:00 +1300</lastBuildDate>
    
	<atom:link href="https://mullikine.github.io/tags/dsls/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Review of &#39;Lambda World 2019 - Language-Oriented Programming with Racket - Matthias Felleisen - YouTube&#39;</title>
      <link>https://mullikine.github.io/posts/review-of-lambda-world-2019-language-oriented-programming-with-racket-matthias-felleisen-youtube/</link>
      <pubDate>Mon, 16 Nov 2020 00:00:00 +1300</pubDate>
      
      <guid>https://mullikine.github.io/posts/review-of-lambda-world-2019-language-oriented-programming-with-racket-matthias-felleisen-youtube/</guid>
      <description>Original article Lambda World 2019 - Language-Oriented Programming with Racket - Matthias Felleisen - YouTube  Notes Process   Develop a programming language in an afternoon.
  Throw them away in the morning.
  The point is they are cheap to produce.
  Verification is the easier problem The more difficult problem is abstraction design.
Behind every framework is a language trying to get out to protect syntactic ideas, semantic wants and the logical ideas that you have.</description>
    </item>
    
  </channel>
</rss>